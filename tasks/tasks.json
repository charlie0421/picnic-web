{
  "tasks": [
    {
      "id": 1,
      "title": "현재 Supabase 클라이언트 구현 검토",
      "description": "Analyze the current Supabase client implementation to identify inconsistencies and areas for improvement in client/server usage.",
      "details": "1. Review all files that import and use Supabase client\n2. Document where createBrowserClient and createServerClient are currently used\n3. Identify instances where the wrong client type is used for the context\n4. Create a report of all inconsistencies found\n5. Map out the current authentication flow and data fetching patterns\n6. Identify potential bottlenecks or performance issues in the current implementation\n\nImplementation notes:\n- Use static code analysis tools to find all Supabase client imports\n- Document findings in a structured format for reference during implementation",
      "testStrategy": "This is an analysis task, so formal testing is not applicable. Success criteria will be a comprehensive report documenting all current Supabase client usage patterns and issues.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Conduct Static Code Analysis",
          "description": "Perform a comprehensive static analysis of the current Supabase client implementation to identify usage patterns and potential issues.",
          "dependencies": [],
          "details": "Use code analysis tools to scan all files that import and use Supabase client. Document all client initialization patterns, configuration options being used, and error handling approaches. Identify any deprecated methods or inconsistent usage patterns across the codebase. Create a report highlighting potential code smells or anti-patterns.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Document Authentication Flow",
          "description": "Map and document all authentication flows implemented with the Supabase client.",
          "dependencies": [
            1
          ],
          "details": "Create detailed sequence diagrams for each authentication flow (sign-up, sign-in, password reset, session refresh, etc.). Document how authentication state is managed throughout the application. Identify potential security vulnerabilities or edge cases in the current implementation. Compare implementation against Supabase best practices.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Create Client Usage Documentation",
          "description": "Develop comprehensive documentation on current Supabase client usage across the application.",
          "dependencies": [
            1,
            2
          ],
          "details": "Create a wiki page or documentation that outlines all database tables being accessed, RLS policies in place, and how they're being queried through the client. Document all custom types and interfaces used with Supabase. Include examples of correct usage patterns for future development. Highlight any custom wrappers or utility functions built around the client.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Perform Performance Assessment",
          "description": "Evaluate the performance implications of current Supabase client implementation and identify optimization opportunities.",
          "dependencies": [
            1,
            3
          ],
          "details": "Profile application performance focusing on Supabase client operations. Measure and document response times for common queries and operations. Identify any N+1 query problems or inefficient data fetching patterns. Recommend optimizations such as query caching, connection pooling, or better use of realtime subscriptions where appropriate. Create a prioritized list of performance improvements.",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Supabase 클라이언트 구조 개선",
      "description": "Create a proper separation between browser and server Supabase clients using @supabase/ssr package.",
      "details": "1. Create a dedicated module for Supabase client initialization\n2. Implement browser client using createBrowserClient from @supabase/ssr\n3. Implement server client using createServerClient from @supabase/ssr\n4. Add proper type definitions for both clients\n5. Ensure environment variables are properly accessed in both contexts\n\nExample implementation:\n```typescript\n// lib/supabase/server.ts\nimport { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport function createServerSupabaseClient() {\n  const cookieStore = cookies()\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        get(name) {\n          return cookieStore.get(name)?.value\n        },\n        set(name, value, options) {\n          cookieStore.set({ name, value, ...options })\n        },\n        remove(name, options) {\n          cookieStore.set({ name, value: '', ...options })\n        },\n      },\n    }\n  )\n}\n\n// lib/supabase/client.ts\nimport { createBrowserClient } from '@supabase/ssr'\n\nexport function createBrowserSupabaseClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n}\n```",
      "testStrategy": "1. Write unit tests to verify both client and server Supabase instances are created correctly\n2. Test that environment variables are properly accessed\n3. Mock cookies for server client tests\n4. Verify type safety of both client implementations",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create server-side Supabase client implementation",
          "description": "Implement a server-side Supabase client using the @supabase/ssr package that handles authentication and data fetching in server components.",
          "dependencies": [],
          "details": "Create a new file for server client implementation. Use createServerClient from @supabase/ssr. Handle cookies properly for authentication. Ensure proper error handling and logging. Document usage patterns for server components.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement browser-side Supabase client",
          "description": "Create a browser-side Supabase client implementation that works with client components and handles real-time subscriptions.",
          "dependencies": [],
          "details": "Create a separate file for browser client implementation. Use createBrowserClient from @supabase/ssr. Implement proper authentication state management. Handle browser-specific features like real-time subscriptions. Document usage patterns for client components.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Define comprehensive type definitions",
          "description": "Create type definitions for the Supabase client implementations, database schema, and API responses.",
          "dependencies": [
            1,
            2
          ],
          "details": "Create types for database tables and relationships. Define types for API responses and requests. Create utility types for common operations. Ensure type safety across both server and browser implementations. Document type usage patterns.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Configure environment variables and settings",
          "description": "Set up environment variables and configuration for different environments (development, production) for the Supabase client.",
          "dependencies": [
            1,
            2
          ],
          "details": "Create environment variable definitions for Supabase URL and keys. Implement validation for required environment variables. Create configuration files for different environments. Document environment setup requirements. Ensure secrets are properly handled.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement testing strategy and examples",
          "description": "Create tests for both server and browser Supabase client implementations and document testing patterns.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Create unit tests for both client implementations. Set up mock Supabase responses for testing. Create integration tests for critical paths. Document testing patterns for components using Supabase. Create example usage patterns in test files.",
          "status": "done"
        }
      ]
    },
    {
      "id": 3,
      "title": "Supabase 컨텍스트 프로바이더 구현",
      "description": "Create a React context provider for Supabase client to ensure consistent access throughout the application.",
      "details": "1. Create a SupabaseProvider component that uses React Context API\n2. Initialize the browser Supabase client within this provider\n3. Provide methods for authentication and common data operations\n4. Ensure the provider is only used in client components\n\nExample implementation:\n```typescript\n'use client'\n\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { createBrowserSupabaseClient } from '@/lib/supabase/client'\nimport type { SupabaseClient } from '@supabase/supabase-js'\n\ntype SupabaseContext = {\n  supabase: SupabaseClient\n}\n\nconst Context = createContext<SupabaseContext | undefined>(undefined)\n\nexport function SupabaseProvider({ children }: { children: React.ReactNode }) {\n  const [supabase] = useState(() => createBrowserSupabaseClient())\n\n  return (\n    <Context.Provider value={{ supabase }}>\n      {children}\n    </Context.Provider>\n  )\n}\n\nexport function useSupabase() {\n  const context = useContext(Context)\n  if (context === undefined) {\n    throw new Error('useSupabase must be used inside SupabaseProvider')\n  }\n  return context\n}\n```",
      "testStrategy": "1. Test that the context provider correctly initializes the Supabase client\n2. Verify that the useSupabase hook throws an error when used outside the provider\n3. Test that the context value is properly passed to child components\n4. Mock Supabase client for testing to avoid actual API calls",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Supabase Context and Provider Component",
          "description": "Implement the Supabase context and provider component to manage Supabase client instance and authentication state",
          "dependencies": [],
          "details": "Create a new file for the Supabase context and provider. Define the context type with proper TypeScript interfaces for the Supabase client, user session, and any other required state. Implement the provider component that initializes the Supabase client and manages authentication state. Add proper error handling and loading states. Ensure the provider is marked as a client component using 'use client' directive.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement useSupabase Custom Hook",
          "description": "Create a custom hook to easily access the Supabase context throughout the application",
          "dependencies": [
            1
          ],
          "details": "Create a useSupabase hook that uses the React useContext hook to access the Supabase context. Add proper error handling to ensure the hook is only used within the context provider. Include TypeScript typing for the return values. Document the hook's usage with JSDoc comments. Test the hook with basic usage patterns.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Integrate Supabase Provider with Application Components",
          "description": "Wrap appropriate components with the Supabase provider and update existing components to use the Supabase context",
          "dependencies": [
            1,
            2
          ],
          "details": "Identify the appropriate level in the component tree to place the Supabase provider (likely in layout.tsx or a high-level wrapper). Update existing components that need Supabase functionality to use the useSupabase hook instead of direct client imports. Ensure authentication-dependent components properly handle loading and unauthenticated states. Test the integration with existing components to verify proper functionality.",
          "status": "done"
        }
      ]
    },
    {
      "id": 4,
      "title": "현재 컴포넌트 구조 분석",
      "description": "Analyze the current component structure to identify components that should be server components vs. client components.",
      "details": "1. Review all components in the codebase\n2. Identify components that primarily handle:\n   - Data fetching (potential server components)\n   - UI rendering without interactivity (potential server components)\n   - Interactive elements (must be client components)\n   - State management (must be client components)\n3. Document current client-side data fetching that could be moved to server components\n4. Identify components with mixed responsibilities that should be split\n5. Create a migration plan for each component\n\nImplementation approach:\n- Create a spreadsheet or document listing all components\n- Categorize each component as 'Server', 'Client', or 'Split needed'\n- Note dependencies between components to understand migration impact",
      "testStrategy": "This is an analysis task, so formal testing is not applicable. Success criteria will be a comprehensive component inventory with clear categorization and migration recommendations.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Component Inventory",
          "description": "Catalog all existing components in the application with their current rendering type, functionality, and usage patterns.",
          "dependencies": [],
          "details": "Create a spreadsheet or document listing all components with columns for: component name, current rendering type (client/server/hybrid), primary functionality, where it's used in the application, and any special requirements (e.g., needs user interaction, relies on browser APIs, etc.). Include component file paths for easy reference.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Server vs. Client Component Analysis",
          "description": "Analyze each component to determine optimal rendering strategy (server or client component) based on its functionality and requirements.",
          "dependencies": [
            1
          ],
          "details": "For each component in the inventory, evaluate: Does it need interactivity? Does it use browser-only APIs? Does it use hooks? Does it need access to request-time data? Mark each component with a recommended rendering strategy and document the reasoning. Flag components that may need to be split into server/client parts.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Dependency Mapping",
          "description": "Create a visual dependency map showing relationships between components and identify potential issues in the current structure.",
          "dependencies": [
            1,
            2
          ],
          "details": "Generate a directed graph showing component dependencies. Identify circular dependencies, client components importing server components, and other architectural issues. Document potential refactoring needs based on Next.js server/client component rules. Use a tool like Mermaid or draw.io for visualization.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Migration Planning",
          "description": "Develop a phased migration plan for transitioning components to their optimal rendering strategy with minimal disruption.",
          "dependencies": [
            2,
            3
          ],
          "details": "Create a prioritized list of components to migrate, starting with leaf components and working up the tree. Document required changes for each component, including: file renaming (.js/.jsx to .server.js/.client.js), code splitting needs, prop adjustments, and potential performance impacts. Include testing strategies for each migration phase.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 5,
      "title": "서버 컴포넌트 데이터 페칭 구현",
      "description": "Refactor data fetching logic to use server components with the server Supabase client.",
      "details": "1. Create utility functions for common data fetching operations using server Supabase client\n2. Move data fetching from client components to server components\n3. Implement proper error handling for server-side data fetching\n4. Use React Suspense for loading states where appropriate\n\nExample implementation:\n```typescript\n// app/posts/page.tsx\nimport { createServerSupabaseClient } from '@/lib/supabase/server'\n\nasync function getPosts() {\n  const supabase = createServerSupabaseClient()\n  const { data, error } = await supabase\n    .from('posts')\n    .select('*')\n    .order('created_at', { ascending: false })\n  \n  if (error) {\n    console.error('Error fetching posts:', error)\n    throw new Error('Failed to fetch posts')\n  }\n  \n  return data\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts()\n  \n  return (\n    <div>\n      <h1>Posts</h1>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```",
      "testStrategy": "1. Write unit tests for data fetching utility functions\n2. Test error handling scenarios\n3. Create integration tests that verify server components correctly fetch and render data\n4. Mock Supabase responses for testing",
      "priority": "high",
      "dependencies": [
        2,
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create server-side data fetching utility functions",
          "description": "Develop reusable utility functions for server-side data fetching using Supabase server client",
          "dependencies": [],
          "details": "Create a set of utility functions that leverage the Supabase server client for data fetching. These functions should handle common data access patterns, support pagination, filtering, and sorting. Implement proper typing for all functions and ensure they're optimized for server component usage. Include documentation for each function explaining its purpose and usage patterns.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement error handling patterns for server components",
          "description": "Design and implement consistent error handling patterns for server component data fetching",
          "dependencies": [
            1
          ],
          "details": "Create error boundary components specifically designed for server components. Implement standardized error handling patterns including error logging, fallback UI components, and retry mechanisms. Ensure errors are properly typed and categorized (network errors, authentication errors, etc.). Develop a strategy for handling errors at different levels of the component tree.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate React Suspense with server components",
          "description": "Set up React Suspense boundaries and loading states for server component data fetching",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement Suspense boundaries at appropriate levels in the component hierarchy. Create loading UI components that provide meaningful feedback during data fetching. Ensure Suspense works correctly with nested server components and parallel data fetching. Test various network conditions to verify the loading states behave as expected.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Refactor existing components to use server-side data fetching",
          "description": "Convert client components to server components where appropriate and update data fetching patterns",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Identify components that can be converted to server components. Refactor these components to use the new server-side data fetching utilities. Update component props and interfaces as needed. Ensure proper separation between server and client components. Test each refactored component to verify functionality remains intact.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Optimize performance of server component data fetching",
          "description": "Implement caching, prefetching, and other performance optimizations for server components",
          "dependencies": [
            4
          ],
          "details": "Implement React Cache for data fetching results. Set up appropriate cache invalidation strategies. Add prefetching for anticipated user interactions. Measure and optimize server component rendering performance. Implement waterfall prevention techniques for parallel data fetching. Document performance improvements and best practices for the team.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "'use client' 지시문을 사용한 클라이언트 컴포넌트 리팩토링",
      "description": "Properly mark interactive components with the 'use client' directive and ensure they follow client component best practices.",
      "details": "1. Add 'use client' directive to all components that:\n   - Use hooks (useState, useEffect, etc.)\n   - Handle user interactions (onClick, onChange, etc.)\n   - Use browser-only APIs\n2. Ensure client components are properly importing the browser Supabase client\n3. Move state management and event handlers to client components\n4. Minimize the size of client component trees by keeping as much as possible in server components\n\nExample refactoring:\n```typescript\n// Before: Mixed component with data fetching and interactivity\nimport { useState, useEffect } from 'react'\nimport { supabase } from '@/lib/supabase'\n\nexport default function PostList() {\n  const [posts, setPosts] = useState([])\n  const [loading, setLoading] = useState(true)\n  \n  useEffect(() => {\n    async function fetchPosts() {\n      const { data, error } = await supabase.from('posts').select('*')\n      if (!error) setPosts(data)\n      setLoading(false)\n    }\n    fetchPosts()\n  }, [])\n  \n  return (\n    <div>\n      {loading ? <p>Loading...</p> : (\n        <ul>\n          {posts.map(post => <li key={post.id}>{post.title}</li>)}\n        </ul>\n      )}\n    </div>\n  )\n}\n\n// After: Split into server and client components\n// app/posts/page.tsx (Server Component)\nimport { createServerSupabaseClient } from '@/lib/supabase/server'\nimport PostList from './PostList'\n\nasync function getPosts() {\n  const supabase = createServerSupabaseClient()\n  const { data, error } = await supabase.from('posts').select('*')\n  if (error) throw new Error('Failed to fetch posts')\n  return data\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts()\n  return <PostList initialPosts={posts} />\n}\n\n// app/posts/PostList.tsx (Client Component)\n'use client'\n\nimport { useState } from 'react'\n\nexport default function PostList({ initialPosts }) {\n  const [posts, setPosts] = useState(initialPosts)\n  \n  return (\n    <ul>\n      {posts.map(post => <li key={post.id}>{post.title}</li>)}\n    </ul>\n  )\n}\n```",
      "testStrategy": "1. Verify that all interactive components have the 'use client' directive\n2. Test that client components correctly receive and render data from server components\n3. Test interactive features like button clicks and form submissions\n4. Ensure client components don't unnecessarily re-render",
      "priority": "high",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Component Identification and Analysis",
          "description": "Identify all components that need to be refactored as client components and analyze their current implementation.",
          "dependencies": [],
          "details": "Create an inventory of all components in the application. Analyze each component to determine if it needs the 'use client' directive based on its interactivity, event handlers, and state management. Document the components that require refactoring and their dependencies.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Add 'use client' Directives",
          "description": "Add the 'use client' directive to all identified components that require client-side functionality.",
          "dependencies": [
            1
          ],
          "details": "Based on the analysis from subtask 1, systematically add the 'use client' directive at the top of each component file that requires client-side functionality. Ensure the directive is placed before any imports or other code in the file.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "State Management Migration",
          "description": "Refactor state management in components to align with the client component architecture.",
          "dependencies": [
            2
          ],
          "details": "Review all state management code in the identified components. Move React hooks (useState, useReducer, useContext) to client components. Ensure state is properly contained within client boundaries. Consider implementing state lifting where necessary to maintain proper data flow between components.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Event Handler Refactoring",
          "description": "Refactor event handlers to ensure they are properly implemented in client components.",
          "dependencies": [
            2,
            3
          ],
          "details": "Identify all event handlers (onClick, onChange, onSubmit, etc.) in the components. Ensure they are contained within client components. Refactor any event handling logic that spans across component boundaries. Test each handler to verify functionality is maintained after refactoring.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Component Tree Optimization",
          "description": "Optimize the component tree to minimize client components and improve performance.",
          "dependencies": [
            3,
            4
          ],
          "details": "Review the refactored component structure to identify opportunities for optimization. Split components to separate client and server parts where possible. Minimize the number of client components to reduce JavaScript bundle size. Implement performance testing to ensure the refactored components maintain or improve application performance.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "정적 및 동적 렌더링 최적화",
      "description": "Identify and implement opportunities for static generation and dynamic rendering based on page content requirements.",
      "details": "1. Analyze each page to determine if it can be statically generated or needs dynamic rendering\n2. Implement static generation for pages with content that doesn't change frequently\n3. Configure revalidation periods for statically generated pages\n4. Ensure dynamic pages use server components for data fetching\n\nImplementation approach:\n```typescript\n// Static page with revalidation\n// app/blog/[slug]/page.tsx\nimport { createServerSupabaseClient } from '@/lib/supabase/server'\n\nexport async function generateStaticParams() {\n  const supabase = createServerSupabaseClient()\n  const { data } = await supabase.from('posts').select('slug')\n  \n  return data?.map(post => ({\n    slug: post.slug,\n  })) || []\n}\n\nasync function getPost(slug) {\n  const supabase = createServerSupabaseClient()\n  const { data } = await supabase\n    .from('posts')\n    .select('*')\n    .eq('slug', slug)\n    .single()\n  \n  return data\n}\n\nexport default async function BlogPost({ params }) {\n  const post = await getPost(params.slug)\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  )\n}\n\nexport const revalidate = 3600 // Revalidate every hour\n```",
      "testStrategy": "1. Test that static pages are correctly pre-rendered\n2. Verify revalidation works as expected\n3. Test dynamic pages with different query parameters\n4. Measure and compare performance between static and dynamic pages",
      "priority": "medium",
      "dependencies": [
        5,
        6
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Page Analysis and Rendering Strategy Mapping",
          "description": "Analyze all pages in the application and determine the optimal rendering strategy for each based on content type and update frequency.",
          "dependencies": [],
          "details": "Create a comprehensive inventory of all pages, categorizing them by data requirements, update frequency, and user interaction patterns. Document which pages should use static generation (SSG), incremental static regeneration (ISR), or server-side rendering (SSR). Include performance metrics and user experience considerations in the analysis.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Static Generation Implementation",
          "description": "Implement static generation for pages with infrequently changing content to improve performance and reduce server load.",
          "dependencies": [
            1
          ],
          "details": "Modify page components to use getStaticProps for data fetching. Ensure proper error handling and fallback states. Implement build-time data fetching for static content. Test the implementation by comparing load times before and after changes.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Revalidation Configuration Setup",
          "description": "Configure incremental static regeneration (ISR) for semi-dynamic pages that require periodic updates.",
          "dependencies": [
            2
          ],
          "details": "Implement revalidation strategies using Next.js ISR capabilities. Set appropriate revalidation intervals based on content update frequency. Add on-demand revalidation triggers where applicable. Document the revalidation strategy for each page and test the revalidation process.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Dynamic Rendering Implementation",
          "description": "Implement server-side rendering or client-side rendering for highly dynamic pages that require real-time data.",
          "dependencies": [
            1,
            3
          ],
          "details": "Identify pages requiring real-time data and implement getServerSideProps or client-side data fetching as appropriate. Optimize server-side rendering with caching headers where possible. Implement loading states and error boundaries for dynamic content. Test performance under various network conditions.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "SEO 및 메타데이터 최적화 구현",
      "description": "Add proper metadata to all pages and implement SEO best practices using Next.js metadata API.",
      "details": "1. Implement metadata for all pages using Next.js metadata API\n2. Create dynamic metadata based on page content\n3. Add Open Graph and Twitter card metadata\n4. Implement structured data where appropriate\n\nExample implementation:\n```typescript\n// app/blog/[slug]/page.tsx\nimport { createServerSupabaseClient } from '@/lib/supabase/server'\nimport { Metadata, ResolvingMetadata } from 'next'\n\ntype Props = {\n  params: { slug: string }\n}\n\nexport async function generateMetadata(\n  { params }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const post = await getPost(params.slug)\n  \n  return {\n    title: post.title,\n    description: post.excerpt,\n    openGraph: {\n      title: post.title,\n      description: post.excerpt,\n      images: [post.featuredImage],\n      type: 'article',\n      publishedTime: post.publishedAt,\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: post.title,\n      description: post.excerpt,\n      images: [post.featuredImage],\n    },\n  }\n}\n\nasync function getPost(slug) {\n  const supabase = createServerSupabaseClient()\n  const { data } = await supabase\n    .from('posts')\n    .select('*')\n    .eq('slug', slug)\n    .single()\n  \n  return data\n}\n\nexport default async function BlogPost({ params }: Props) {\n  const post = await getPost(params.slug)\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  )\n}\n```",
      "testStrategy": "1. Verify metadata is correctly generated for each page\n2. Test dynamic metadata generation with different content\n3. Use tools like Lighthouse to verify SEO score improvements\n4. Test structured data using Google's Rich Results Test",
      "priority": "medium",
      "dependencies": [
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Basic Metadata Setup",
          "description": "Implement basic metadata for all static pages using Next.js metadata API",
          "dependencies": [],
          "details": "Create a consistent metadata structure for static pages including title, description, and Open Graph tags. Set up default metadata in the root layout.js file and implement page-specific overrides. Ensure proper favicon and site icon implementation.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Dynamic Metadata Generation",
          "description": "Implement dynamic metadata for content-driven pages",
          "dependencies": [
            1
          ],
          "details": "Create generateMetadata functions for dynamic routes like blog posts, product pages, and category pages. Ensure metadata reflects the specific content being displayed. Implement proper canonical URLs and alternates for pagination or filtered views. Test with various content types to ensure metadata is correctly generated.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Structured Data Implementation",
          "description": "Add JSON-LD structured data for relevant page types",
          "dependencies": [
            2
          ],
          "details": "Implement JSON-LD structured data for products, articles, FAQs, and other relevant content types. Create reusable structured data components that can be populated dynamically. Test implementation using Google's Rich Results Test and Schema Validator. Ensure proper integration with the Next.js metadata API.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "Jest 및 React Testing Library 설정",
      "description": "Configure Jest and React Testing Library for the project to enable component and utility testing.",
      "details": "1. Install required dependencies:\n   - jest\n   - @testing-library/react\n   - @testing-library/jest-dom\n   - jest-environment-jsdom\n2. Configure Jest in package.json or jest.config.js\n3. Setup test utilities and mocks\n4. Configure TypeScript for testing\n\nImplementation steps:\n```bash\nnpm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom @testing-library/user-event\n```\n\nCreate jest.config.js:\n```javascript\nconst nextJest = require('next/jest')\n\nconst createJestConfig = nextJest({\n  dir: './',\n})\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  testEnvironment: 'jest-environment-jsdom',\n  moduleNameMapper: {\n    '^@/(.*)$': '<rootDir>/src/$1',\n  },\n  collectCoverage: true,\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx,ts,tsx}',\n    '!src/**/*.d.ts',\n    '!src/**/_*.{js,jsx,ts,tsx}',\n    '!src/**/*.stories.{js,jsx,ts,tsx}',\n  ],\n}\n\nmodule.exports = createJestConfig(customJestConfig)\n```\n\nCreate jest.setup.js:\n```javascript\nimport '@testing-library/jest-dom'\n\n// Mock Supabase\njest.mock('@/lib/supabase/client', () => ({\n  createBrowserSupabaseClient: jest.fn(() => ({\n    auth: {\n      getUser: jest.fn(),\n      signIn: jest.fn(),\n      signOut: jest.fn(),\n    },\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          data: [],\n          error: null,\n        })),\n      })),\n    })),\n  })),\n}))\n\njest.mock('@/lib/supabase/server', () => ({\n  createServerSupabaseClient: jest.fn(() => ({\n    auth: {\n      getUser: jest.fn(),\n    },\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          data: [],\n          error: null,\n        })),\n      })),\n    })),\n  })),\n}))\n```",
      "testStrategy": "1. Verify Jest configuration by running a simple test\n2. Test that mocks are working correctly\n3. Ensure test environment correctly simulates the Next.js environment\n4. Verify code coverage reporting works",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Install Testing Dependencies",
          "description": "Install Jest, React Testing Library, and other necessary testing packages",
          "dependencies": [],
          "details": "Install Jest, @testing-library/react, @testing-library/jest-dom, @testing-library/user-event, and jest-environment-jsdom. Update package.json with appropriate test scripts. Configure any necessary TypeScript settings for Jest.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Configure Jest for Next.js",
          "description": "Set up Jest configuration to work with Next.js environment",
          "dependencies": [
            1
          ],
          "details": "Create jest.config.js file with appropriate Next.js settings. Configure moduleNameMapper for handling CSS, image imports, and other assets. Set up the correct test environment and transform settings for JSX/TSX files.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create Mock Setup for External Dependencies",
          "description": "Set up mocks for Supabase, Next.js router, and other external services",
          "dependencies": [
            2
          ],
          "details": "Create __mocks__ directory with mock implementations for Supabase client, Next.js useRouter, and any other external services. Set up a test utilities file with common testing functions and providers for wrapping components during tests.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Initial Component Tests",
          "description": "Write basic test cases for a simple component to verify the testing setup",
          "dependencies": [
            3
          ],
          "details": "Create a test file for a simple component (e.g., Button or Header). Write tests for rendering, user interactions, and any component-specific logic. Ensure tests pass and the setup is working correctly before proceeding with more complex component testing.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "테스트 유틸리티 및 목 생성",
      "description": "Develop test utilities and mocks to facilitate testing of components that use Supabase and Next.js features.",
      "details": "1. Create test utilities for rendering components with providers\n2. Develop mocks for Supabase client\n3. Create mocks for Next.js features (router, headers, cookies)\n4. Implement helper functions for common testing scenarios\n\nExample implementation:\n```typescript\n// src/test/utils.tsx\nimport { render } from '@testing-library/react'\nimport { SupabaseProvider } from '@/lib/supabase/provider'\n\nconst customRender = (ui, options = {}) => {\n  return render(ui, {\n    wrapper: ({ children }) => (\n      <SupabaseProvider>{children}</SupabaseProvider>\n    ),\n    ...options,\n  })\n}\n\n// Mock data\nexport const mockPosts = [\n  { id: 1, title: 'Test Post 1', content: 'Content 1' },\n  { id: 2, title: 'Test Post 2', content: 'Content 2' },\n]\n\n// Mock Supabase responses\nexport const mockSupabaseFrom = (tableName, data, error = null) => {\n  return {\n    from: jest.fn((table) => {\n      if (table === tableName) {\n        return {\n          select: jest.fn(() => ({\n            eq: jest.fn(() => ({ data, error })),\n            order: jest.fn(() => ({ data, error })),\n            data,\n            error,\n          })),\n          insert: jest.fn(() => ({ data, error })),\n          update: jest.fn(() => ({ data, error })),\n          delete: jest.fn(() => ({ data, error })),\n        }\n      }\n      return {\n        select: jest.fn(() => ({ data: null, error: null })),\n      }\n    }),\n  }\n}\n\nexport { customRender as render }\n```",
      "testStrategy": "1. Test the custom render function with a simple component\n2. Verify mocks correctly simulate Supabase responses\n3. Test that providers are correctly applied in the test environment\n4. Create example tests using the utilities to validate their effectiveness",
      "priority": "medium",
      "dependencies": [
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create render utilities for component testing",
          "description": "Develop utilities to simplify rendering components in test environments with proper context providers and test configurations",
          "dependencies": [],
          "details": "Implement render utilities that wrap components with necessary providers (theme, auth, etc.), handle test rendering configurations, and provide helper methods for querying and interacting with rendered components. Include utilities for both shallow and deep rendering approaches.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Supabase mocking utilities",
          "description": "Create comprehensive mocks for Supabase client, authentication, and database operations",
          "dependencies": [
            1
          ],
          "details": "Develop mock implementations for Supabase client, auth methods, database queries, and real-time subscriptions. Include utilities to simulate successful responses, errors, and edge cases. Ensure mocks can be easily configured for different test scenarios.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Next.js feature mocks",
          "description": "Create mocks for Next.js specific features like routing, data fetching, and server components",
          "dependencies": [
            1
          ],
          "details": "Implement mock utilities for Next.js router, navigation methods, server-side rendering functions, and data fetching methods. Include mocks for useRouter, Link component behavior, and other Next.js specific APIs. Ensure compatibility with the application's routing structure.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create test helper functions",
          "description": "Implement reusable helper functions for common testing patterns and assertions",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Develop helper functions for common testing tasks such as form interactions, authentication state simulation, waiting for async operations, and custom assertions. Create utilities for generating test data, simulating user interactions, and validating component states across different test scenarios.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 11,
      "title": "Supabase 클라이언트 유틸리티 유닛 테스트 작성",
      "description": "Create comprehensive unit tests for the Supabase client utility functions.",
      "details": "1. Write tests for createServerSupabaseClient function\n2. Write tests for createBrowserSupabaseClient function\n3. Test SupabaseProvider and useSupabase hook\n4. Test error handling in Supabase utility functions\n\nExample test implementation:\n```typescript\n// src/lib/supabase/client.test.ts\nimport { createBrowserSupabaseClient } from './client'\n\njest.mock('@supabase/ssr', () => ({\n  createBrowserClient: jest.fn(() => ({\n    // Mock Supabase client methods\n  })),\n}))\n\ndescribe('createBrowserSupabaseClient', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('should create a browser Supabase client', () => {\n    const client = createBrowserSupabaseClient()\n    expect(client).toBeDefined()\n  })\n})\n\n// src/lib/supabase/provider.test.tsx\nimport { render, screen } from '@testing-library/react'\nimport { SupabaseProvider, useSupabase } from './provider'\n\nconst TestComponent = () => {\n  const { supabase } = useSupabase()\n  return <div>Supabase Client: {supabase ? 'Available' : 'Not Available'}</div>\n}\n\ndescribe('SupabaseProvider', () => {\n  it('should provide Supabase client to children', () => {\n    render(\n      <SupabaseProvider>\n        <TestComponent />\n      </SupabaseProvider>\n    )\n    \n    expect(screen.getByText(/Supabase Client: Available/)).toBeInTheDocument()\n  })\n\n  it('should throw error when useSupabase is used outside provider', () => {\n    // Suppress console.error for this test\n    const originalError = console.error\n    console.error = jest.fn()\n    \n    expect(() => {\n      render(<TestComponent />)\n    }).toThrow('useSupabase must be used inside SupabaseProvider')\n    \n    console.error = originalError\n  })\n})\n```",
      "testStrategy": "1. Test that client creation functions return expected objects\n2. Verify error handling works correctly\n3. Test that context providers correctly provide values to consumers\n4. Use mocks to avoid actual API calls during testing",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        10
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement server-side Supabase client tests",
          "description": "Create comprehensive unit tests for the server-side Supabase client implementation",
          "dependencies": [],
          "details": "Write tests that verify server-side Supabase client initialization, authentication methods, database queries, and storage operations. Set up proper mocking for Supabase responses. Include tests for successful operations and edge cases. Ensure tests run in a Node.js environment.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement browser-side Supabase client tests",
          "description": "Create comprehensive unit tests for the browser-side Supabase client implementation",
          "dependencies": [
            1
          ],
          "details": "Write tests that verify browser-specific Supabase client behavior, including local storage integration, cookie handling, and browser-specific authentication flows. Set up proper DOM mocking and ensure tests run in a simulated browser environment. Test both successful operations and edge cases.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement provider and hook tests",
          "description": "Create tests for Supabase context providers and React hooks",
          "dependencies": [
            2
          ],
          "details": "Test the Supabase provider component and associated React hooks. Verify that the provider correctly initializes the Supabase client and provides it to child components. Test hooks for authentication state, data fetching, and real-time subscriptions. Use React Testing Library to render components and test hook behavior.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement error handling tests",
          "description": "Create tests that verify proper error handling in all Supabase client utilities",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Test error scenarios including network failures, authentication errors, permission issues, and invalid operations. Verify that errors are properly caught, logged, and handled. Test error recovery mechanisms and retry logic if applicable. Ensure consistent error handling across both server and browser environments.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 12,
      "title": "컴포넌트 테스트 작성",
      "description": "Create tests for key UI components to ensure they render correctly and handle user interactions properly.",
      "details": "1. Identify critical UI components for testing\n2. Write tests for component rendering\n3. Test user interactions (clicks, form inputs, etc.)\n4. Test component state changes\n\nExample test implementation:\n```typescript\n// src/components/PostCard.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport PostCard from './PostCard'\n\nconst mockPost = {\n  id: 1,\n  title: 'Test Post',\n  excerpt: 'This is a test post',\n  slug: 'test-post',\n}\n\ndescribe('PostCard', () => {\n  it('renders post information correctly', () => {\n    render(<PostCard post={mockPost} />)\n    \n    expect(screen.getByText('Test Post')).toBeInTheDocument()\n    expect(screen.getByText('This is a test post')).toBeInTheDocument()\n    expect(screen.getByRole('link')).toHaveAttribute('href', '/blog/test-post')\n  })\n\n  it('navigates to post page when clicked', () => {\n    render(<PostCard post={mockPost} />)\n    \n    const link = screen.getByRole('link')\n    fireEvent.click(link)\n    \n    // Test navigation would go here if using a router mock\n  })\n})\n```",
      "testStrategy": "1. Test that components render with different props\n2. Verify user interactions trigger expected behaviors\n3. Test loading, error, and success states\n4. Test accessibility features",
      "priority": "medium",
      "dependencies": [
        6,
        10
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Rendering Tests",
          "description": "Create tests to verify components render correctly with different props and in different states",
          "dependencies": [],
          "details": "Write tests that check if components render without errors, display the correct content based on props, handle conditional rendering correctly, and render child components as expected. Use snapshot testing where appropriate to detect unexpected UI changes.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Interaction Tests",
          "description": "Create tests for user interactions like clicks, inputs, and form submissions",
          "dependencies": [
            1
          ],
          "details": "Simulate user events (clicks, typing, etc.) and verify components respond correctly. Test form validations, button click handlers, hover states, and other interactive elements. Use testing libraries to mock user interactions and verify the expected outcomes.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement State Management Tests",
          "description": "Test component state changes and integration with state management systems",
          "dependencies": [
            1,
            2
          ],
          "details": "Verify that component state updates correctly in response to props changes and user interactions. Test integration with Redux, Context API, or other state management solutions. Ensure that components re-render appropriately when state changes and that state is maintained correctly across component lifecycle events.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Accessibility Tests",
          "description": "Test components for accessibility compliance and screen reader compatibility",
          "dependencies": [
            1
          ],
          "details": "Verify that components meet WCAG guidelines. Test keyboard navigation, focus management, proper ARIA attributes, color contrast, and screen reader compatibility. Use accessibility testing tools to automate checks and ensure components are usable by people with disabilities.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 13,
      "title": "페이지 통합 테스트 작성",
      "description": "Create integration tests for key pages to ensure they correctly fetch and display data.",
      "details": "1. Identify critical pages for testing\n2. Mock server-side data fetching\n3. Test page rendering with different data scenarios\n4. Test page interactions and navigation\n\nExample test implementation:\n```typescript\n// src/app/posts/page.test.tsx\nimport { render, screen } from '@testing-library/react'\nimport PostsPage from './page'\nimport { mockPosts } from '@/test/utils'\n\n// Mock the data fetching function\njest.mock('@/lib/supabase/server', () => ({\n  createServerSupabaseClient: jest.fn(() => ({\n    from: jest.fn(() => ({\n      select: jest.fn(() => ({\n        order: jest.fn(() => ({\n          data: mockPosts,\n          error: null,\n        })),\n      })),\n    })),\n  })),\n}))\n\ndescribe('PostsPage', () => {\n  it('renders posts correctly', async () => {\n    // Since this is an async component, we need to render it differently\n    const PostsPageComponent = await PostsPage()\n    render(PostsPageComponent)\n    \n    expect(screen.getByText('Posts')).toBeInTheDocument()\n    expect(screen.getByText('Test Post 1')).toBeInTheDocument()\n    expect(screen.getByText('Test Post 2')).toBeInTheDocument()\n  })\n\n  it('handles empty posts array', async () => {\n    // Override the mock for this test\n    jest.mock('@/lib/supabase/server', () => ({\n      createServerSupabaseClient: jest.fn(() => ({\n        from: jest.fn(() => ({\n          select: jest.fn(() => ({\n            order: jest.fn(() => ({\n              data: [],\n              error: null,\n            })),\n          })),\n        })),\n      })),\n    }))\n    \n    const PostsPageComponent = await PostsPage()\n    render(PostsPageComponent)\n    \n    expect(screen.getByText('No posts found')).toBeInTheDocument()\n  })\n})\n```",
      "testStrategy": "1. Test pages with different data scenarios (empty, error, loaded)\n2. Verify that pages correctly handle loading and error states\n3. Test that pages correctly render components with fetched data\n4. Test page-level interactions",
      "priority": "low",
      "dependencies": [
        5,
        7,
        10
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up data fetching mocks",
          "description": "Create mock implementations for all data fetching functions used by the page",
          "dependencies": [],
          "details": "Identify all data fetching functions used by the page. Create mock implementations that return predefined test data. Set up a testing utility that allows switching between different mock data scenarios (empty data, full data, partial data). Ensure mocks properly simulate loading states and timing.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement page rendering tests",
          "description": "Test that the page renders correctly with different data scenarios",
          "dependencies": [
            1
          ],
          "details": "Create tests that verify the page renders correctly with various data scenarios. Test rendering with full data, empty data, and partial data. Verify that all expected UI elements are present and contain the correct content. Test that server and client components integrate properly. Verify that loading states are displayed appropriately.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop user interaction tests",
          "description": "Test all interactive elements and user flows on the page",
          "dependencies": [
            2
          ],
          "details": "Identify all interactive elements on the page (buttons, forms, links, etc.). Create tests for each interaction, verifying that the correct actions occur. Test form submissions, navigation events, and state changes. Verify that client-side state updates correctly after interactions. Test any conditional rendering based on user interactions.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement error state tests",
          "description": "Test how the page handles various error conditions",
          "dependencies": [
            1,
            2
          ],
          "details": "Configure data fetching mocks to simulate different error scenarios (network errors, server errors, validation errors). Test that appropriate error messages are displayed to the user. Verify error boundary functionality if implemented. Test recovery paths from error states. Ensure errors are logged or reported appropriately.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "코드 커버리지 리포팅 설정",
      "description": "Set up code coverage reporting with Jest and configure minimum coverage thresholds.",
      "details": "1. Configure Jest to collect coverage information\n2. Set coverage thresholds (minimum 70% as per requirements)\n3. Configure coverage report output formats\n4. Add coverage reporting to npm scripts\n\nImplementation steps:\n1. Update Jest configuration:\n```javascript\n// jest.config.js\nconst customJestConfig = {\n  // ... existing config\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx,ts,tsx}',\n    '!src/**/*.d.ts',\n    '!src/**/_*.{js,jsx,ts,tsx}',\n    '!src/**/*.stories.{js,jsx,ts,tsx}',\n    '!**/node_modules/**',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 70,\n      functions: 70,\n      lines: 70,\n      statements: 70,\n    },\n  },\n  coverageReporters: ['json', 'lcov', 'text', 'clover'],\n}\n```\n\n2. Add npm scripts:\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\"\n  }\n}\n```",
      "testStrategy": "1. Run test coverage to verify configuration works\n2. Check that coverage reports are generated in expected formats\n3. Verify that coverage thresholds are enforced\n4. Test that coverage reporting works in CI environment",
      "priority": "low",
      "dependencies": [
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Configure Jest for code coverage collection",
          "description": "Set up Jest configuration to collect code coverage metrics during test runs",
          "dependencies": [],
          "details": "Update Jest configuration to enable coverage collection by adding the appropriate flags in package.json or jest.config.js. Configure the coverage directory and ensure the correct file patterns are included/excluded from coverage analysis.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Establish code coverage thresholds",
          "description": "Define minimum acceptable code coverage thresholds for the project",
          "dependencies": [
            1
          ],
          "details": "Set up coverage thresholds in the Jest configuration for statements, branches, functions, and lines. Determine appropriate threshold values based on project requirements. Configure Jest to fail tests if coverage falls below these thresholds.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate code coverage reporting with CI pipeline",
          "description": "Configure CI system to generate and display code coverage reports",
          "dependencies": [
            1,
            2
          ],
          "details": "Update CI configuration to run tests with coverage enabled. Configure the CI pipeline to generate coverage reports in the appropriate format (HTML, lcov, etc.). Set up the CI to fail builds if coverage thresholds are not met. Consider adding coverage badges to the repository README.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "CI/CD 파이프라인에 테스트 커버리지 통합",
      "description": "Configure CI/CD pipeline to run tests and verify code coverage meets thresholds.",
      "details": "1. Configure GitHub Actions or other CI/CD service to run tests\n2. Add coverage verification step to CI pipeline\n3. Configure reporting of test results and coverage\n4. Set up PR checks based on test results and coverage\n\nExample GitHub Actions configuration:\n```yaml\n# .github/workflows/test.yml\nname: Test\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Run tests with coverage\n        run: npm run test:coverage\n      \n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          token: ${{ secrets.CODECOV_TOKEN }}\n          directory: ./coverage/\n          fail_ci_if_error: true\n```",
      "testStrategy": "1. Test the CI configuration with a sample PR\n2. Verify that tests run correctly in the CI environment\n3. Check that coverage reports are correctly uploaded\n4. Test that PR checks work as expected for both passing and failing tests",
      "priority": "low",
      "dependencies": [
        14
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Configure CI/CD Workflow",
          "description": "Set up the basic CI/CD workflow configuration using GitHub Actions or similar service",
          "dependencies": [],
          "details": "Create workflow YAML file that defines the CI pipeline, including environment setup, dependency installation, and test execution. Configure the workflow to trigger on push and pull requests to relevant branches. Ensure proper caching of dependencies to optimize build times.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Test Coverage Reporting",
          "description": "Configure the CI pipeline to generate and report test coverage metrics",
          "dependencies": [
            1
          ],
          "details": "Integrate a coverage tool (like Istanbul/nyc, Jest coverage, or similar) into the CI workflow. Configure the tool to generate coverage reports in appropriate formats (HTML, JSON, lcov). Set up the CI to upload coverage artifacts or publish them to a dashboard service. Define minimum coverage thresholds if applicable.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement PR Status Checks",
          "description": "Configure the repository to require passing CI checks before merging pull requests",
          "dependencies": [
            1,
            2
          ],
          "details": "Set up branch protection rules in the repository settings. Configure required status checks that must pass before merging. Implement PR comments that show test results and coverage changes. Add status badges to the repository README to display current build status and coverage metrics.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "확장된 소셜 로그인 통합 구현 (Google, Apple, Kakao, WeChat)",
      "description": "현재 지원 중인 소셜 로그인 기능을 확장하여 Google, Apple, Kakao, WeChat 로그인을 모두 지원하도록 통합 구현하는 작업입니다. 이 작업은 Supabase 클라이언트 구조 개선 작업(ID 2)에 의존성을 가집니다.",
      "status": "done",
      "dependencies": [
        "2",
        "17"
      ],
      "priority": "high",
      "details": "이 작업은 다음 단계로 진행됩니다:\n\n1. **현재 구현 상태 분석**:\n   - 기존 소셜 로그인 구현 코드 검토\n   - 현재 지원 중인 플랫폼과 미지원 플랫폼 식별\n   - Supabase 클라이언트 구조와의 통합 지점 파악\n\n2. **각 플랫폼별 OAuth 설정**:\n   - Google OAuth 클라이언트 설정 및 API 키 발급\n   - Apple Sign-In 개발자 계정 설정 및 인증서 생성\n   - Kakao 개발자 계정 설정 및 앱 등록\n   - WeChat 개발자 계정 설정 및 앱 ID 발급\n   - 각 플랫폼의 콜백 URL 설정 및 권한 범위 정의\n\n3. **인증 흐름 구현**:\n   - 각 플랫폼별 로그인 버튼 UI 구현\n   - OAuth 인증 요청 처리 로직 구현\n   - 콜백 처리 및 토큰 교환 로직 구현\n   - 사용자 프로필 정보 가져오기 및 저장 로직 구현\n   - 토큰 갱신 및 세션 관리 로직 구현\n\n4. **사용자 데이터 통합**:\n   - 각 플랫폼에서 가져온 사용자 정보 표준화\n   - 기존 계정과의 연동 처리 (이메일 중복 확인 등)\n   - 사용자 프로필 정보 업데이트 로직 구현\n\n5. **에러 처리 및 예외 상황 관리**:\n   - 인증 실패 시나리오 처리\n   - 네트워크 오류 처리\n   - 토큰 만료 및 갱신 실패 처리\n   - 사용자 취소 처리\n\n6. **보안 고려사항**:\n   - 토큰 저장 방식 보안 검토\n   - CSRF 방지 대책 구현\n   - 민감 정보 처리 방식 검토\n\n7. **성능 최적화**:\n   - 로그인 프로세스 지연 시간 최소화\n   - 필요한 사용자 정보만 요청하도록 스코프 최적화\n\n모든 구현은 Supabase 클라이언트 구조와 통합되어야 하며, 기존 인증 시스템과 원활하게 작동해야 합니다.",
      "testStrategy": "소셜 로그인 통합 구현의 테스트 전략은 다음과 같습니다:\n\n1. **단위 테스트**:\n   - 각 소셜 로그인 서비스 클래스에 대한 단위 테스트 작성\n   - OAuth 요청 생성 및 파라미터 검증 테스트\n   - 콜백 처리 및 토큰 파싱 로직 테스트\n   - 사용자 프로필 정보 매핑 테스트\n   - 에러 처리 로직 테스트\n\n2. **통합 테스트**:\n   - 각 소셜 로그인 플로우의 전체 통합 테스트\n   - Supabase 클라이언트와의 통합 테스트\n   - 사용자 데이터 저장 및 조회 통합 테스트\n   - 세션 관리 통합 테스트\n\n3. **모의(Mock) 테스트**:\n   - 각 소셜 로그인 API에 대한 모의 응답 설정\n   - 다양한 응답 시나리오(성공, 실패, 오류)에 대한 테스트\n   - 네트워크 지연 및 타임아웃 시나리오 테스트\n\n4. **E2E 테스트**:\n   - 실제 소셜 로그인 플로우를 시뮬레이션하는 E2E 테스트\n   - 테스트 계정을 사용한 실제 로그인 테스트\n   - 다양한 브라우저 및 기기에서의 호환성 테스트\n\n5. **보안 테스트**:\n   - 토큰 저장 및 관리 보안 테스트\n   - CSRF 취약점 테스트\n   - 세션 하이재킹 방지 테스트\n\n6. **수동 테스트 체크리스트**:\n   - 각 플랫폼별 로그인 성공 시나리오 테스트\n   - 로그인 취소 시나리오 테스트\n   - 권한 거부 시나리오 테스트\n   - 계정 연동 및 분리 테스트\n   - 로그아웃 및 세션 만료 테스트\n\n7. **성능 테스트**:\n   - 로그인 프로세스 응답 시간 측정\n   - 동시 다수 사용자 로그인 시나리오 테스트\n\n모든 테스트는 개발 환경, 스테이징 환경, 그리고 최종적으로 프로덕션 환경에서 순차적으로 수행되어야 합니다. 테스트 결과는 문서화하여 향후 참조할 수 있도록 합니다.",
      "subtasks": [
        {
          "id": 1,
          "title": "현재 소셜 로그인 구조 분석 및 공통 인증 인터페이스 설계",
          "description": "기존 소셜 로그인 구현을 분석하고 Google, Apple, Kakao, WeChat을 통합할 수 있는 공통 인증 인터페이스를 설계합니다.",
          "dependencies": [],
          "details": "1. 기존 소셜 로그인 코드 구조 분석\n2. Supabase 클라이언트와의 통합 지점 파악\n3. 모든 소셜 로그인 제공자를 지원할 수 있는 공통 인터페이스 설계\n4. 인증 흐름 다이어그램 작성\n5. 각 플랫폼별 필요한 사용자 정보 매핑 정의\n<info added on 2025-05-21T16:42:08.717Z>\n## 현재 소셜 로그인 구조 분석\n\n### 분석된 현재 코드 구조\n\n1. **인증 관련 주요 파일들**:\n   - `lib/supabase/auth-provider.tsx`: 현재 사용 중인 통합 AuthProvider (AfterProvider 통합 작업 #17 완료)\n   - `components/features/auth/SocialLoginButtons.tsx`: 소셜 로그인 버튼 컴포넌트\n   - `app/auth/callback/[provider]/page.tsx`: 소셜 로그인 콜백 처리 페이지\n\n2. **현재 지원 중인 소셜 로그인 제공자**:\n   - 코드상으로는 `'google' | 'apple' | 'kakao' | 'wechat'` 타입이 정의되어 있음\n   - `signInWithOAuth` 함수에서 이 4개의 제공자 타입을 받음\n   - 실제 구현에서 wechat은 Supabase Provider로 직접 지원되지 않아 별도 처리 필요\n\n3. **현재 구현 상태**:\n   - Google, Apple은 Supabase 공식 지원으로 기본 구현 가능\n   - Kakao는 Supabase Provider로 지원되어 기본 구현 가능\n   - WeChat은 별도 API 구현 필요 (Supabase에서 직접 지원하지 않음)\n   - 현재 `signInWithOAuth` 함수는 provider를 Provider 타입으로 캐스팅하여 사용\n\n4. **OAuth 흐름**:\n   - 사용자가 소셜 로그인 버튼 클릭 -> `handleSocialLogin` 호출\n   - `signInWithOAuth` -> Supabase OAuth 호출 -> 해당 제공자 로그인 페이지로 리디렉션\n   - 인증 후 `auth/callback/[provider]/page.tsx`로 리디렉션되어 콜백 처리\n   - 콜백에서 세션 정보 저장 및 원래 페이지로 복귀\n\n5. **사용자 프로필 관리**:\n   - 인증 후 사용자 정보는 Supabase `user_profiles` 테이블에 저장\n   - 프로필 데이터는 메모리 캐싱 및 상태 관리를 통해 최적화\n   - `UserProfiles` 인터페이스로 정의된 사용자 프로필 구조 사용\n\n### 개선 필요 사항 및 공통 인터페이스 설계\n\n1. **공통 인증 인터페이스 확장**:\n   ```typescript\n   type SocialLoginProvider = 'google' | 'apple' | 'kakao' | 'wechat';\n\n   interface AuthProviderInterface {\n     // 기존 메서드\n     signInWithOAuth(provider: SocialLoginProvider): Promise<{ error: Error | null }>;\n     \n     // 개선된 메서드\n     signInWithOAuth(provider: SocialLoginProvider, options?: {\n       scopes?: string[];\n       redirectUrl?: string;\n       additionalParams?: Record<string, string>;\n     }): Promise<{ error: Error | null }>;\n   }\n   ```\n\n2. **WeChat 통합 설계**:\n   - WeChat은 Supabase 직접 지원이 없으므로 별도 API 구현 필요\n   - OAuth 인증 처리 후 Supabase 사용자 생성 및 프로필 연결 로직 구현\n   - 기존 인증 흐름과 통합을 위한 커스텀 콜백 처리기 필요\n\n3. **플랫폼별 설정 관리**:\n   - 각 플랫폼(Google, Apple, Kakao, WeChat)별 OAuth 설정 객체 정의\n   - 통합 설정 관리를 위한 구조 생성 (클라이언트 ID, 인증 엔드포인트 등)\n\n4. **개선된 에러 처리 및 로깅**:\n   - 각 플랫폼별 특수 에러 처리 로직 구현\n   - 통합된 에러 코드 및 메시지 시스템 설계\n   - 개발/디버깅을 위한 상세 로깅 메커니즘\n\n5. **콜백 통합 처리**:\n   - 통합된 콜백 핸들러로 다양한 제공자 처리\n   - 제공자별 특수 처리 로직 추가\n   - 상태 저장 및 검증 메커니즘 강화\n\n### 인터페이스 구현 계획\n\n1. **SocialAuthService 클래스 설계**:\n   ```typescript\n   class SocialAuthService {\n     // 기본 설정\n     constructor(private supabase: SupabaseClient) {}\n     \n     // 제공자별 로그인 처리\n     async signInWithGoogle(options?: SocialAuthOptions): Promise<AuthResult> {...}\n     async signInWithApple(options?: SocialAuthOptions): Promise<AuthResult> {...}\n     async signInWithKakao(options?: SocialAuthOptions): Promise<AuthResult> {...}\n     async signInWithWeChat(options?: SocialAuthOptions): Promise<AuthResult> {...}\n     \n     // 통합 메서드\n     async signInWithProvider(provider: SocialLoginProvider, options?: SocialAuthOptions): Promise<AuthResult> {...}\n     \n     // 콜백 처리\n     async handleCallback(provider: SocialLoginProvider, params: Record<string, string>): Promise<AuthResult> {...}\n   }\n   ```\n\n2. **각 제공자별 설정 및 처리 로직 분리**:\n   - `lib/supabase/social/google.ts`\n   - `lib/supabase/social/apple.ts`\n   - `lib/supabase/social/kakao.ts`\n   - `lib/supabase/social/wechat.ts`\n\n3. **향후 확장을 위한 팩토리 패턴 적용**:\n   - 새로운 소셜 로그인 제공자 추가를 쉽게 할 수 있는 구조 설계\n   - 모듈식 접근으로 코드 유지보수성 향상\n</info added on 2025-05-21T16:42:08.717Z>\n<info added on 2025-05-21T16:50:42.556Z>\n## 작업 구현 내용\n\n1. **소셜 로그인 모듈의 공통 인터페이스 설계 및 구현 완료**:\n   - 모든 소셜 로그인 제공자(Google, Apple, Kakao, WeChat)에 대한 통합 인터페이스 구현\n   - 각 제공자별 특화된 설정 및 인증 처리 로직 구현\n   - 오류 처리를 위한 공통 SocialAuthError 클래스 구현\n   - 각 제공자별로 개별 모듈로 분리하여 유지보수성 향상\n\n2. **파일 구조**:\n   - `lib/supabase/social/types.ts`: 공통 타입, 인터페이스, 오류 코드 정의\n   - `lib/supabase/social/google.ts`: Google 소셜 로그인 구현\n   - `lib/supabase/social/apple.ts`: Apple 소셜 로그인 구현\n   - `lib/supabase/social/kakao.ts`: Kakao 소셜 로그인 구현\n   - `lib/supabase/social/wechat.ts`: WeChat 소셜 로그인 구현\n   - `lib/supabase/social/service.ts`: 통합 소셜 로그인 서비스 클래스 구현\n   - `lib/supabase/social/index.ts`: 모듈 진입점 및 유틸리티 함수\n\n3. **SocialLoginButtons 컴포넌트 업데이트**:\n   - 기존 코드를 새로운 인터페이스를 사용하도록 리팩토링\n   - UI 디자인은 기존과 유사하게 유지\n\n4. **인증 콜백 처리 개선**:\n   - 콜백 페이지를 업데이트하여 새로운 인터페이스 사용\n   - 오류 처리 및 사용자 메시지 개선\n\n## 주요 개선 사항\n\n1. **유지보수성 향상**:\n   - 각 제공자별 로직이 분리되어 변경 및 추가가 용이\n   - 공통 타입과 인터페이스를 통해 일관성 유지\n\n2. **오류 처리 개선**:\n   - 구체적인 오류 코드와 메시지로 디버깅 용이\n   - 사용자에게 더 명확한 오류 메시지 제공\n\n3. **확장성**:\n   - 새로운 소셜 로그인 제공자 추가가 용이한 구조\n   - 기존 코드 변경 없이 새로운 제공자 모듈만 추가 가능\n</info added on 2025-05-21T16:50:42.556Z>",
          "status": "done",
          "testStrategy": "인터페이스 설계 문서 검토 및 기존 코드와의 호환성 확인"
        },
        {
          "id": 2,
          "title": "Google OAuth 로그인 구현",
          "description": "Google OAuth를 사용하여 사용자 인증 및 프로필 정보 가져오기 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. Google Cloud Console에서 OAuth 클라이언트 ID 및 시크릿 설정\n2. 로그인 요청 및 콜백 처리 로직 구현\n3. 액세스 토큰 및 리프레시 토큰 관리\n4. 사용자 프로필 정보 가져오기 및 Supabase 사용자 데이터와 통합\n5. 토큰 갱신 로직 구현\n<info added on 2025-05-21T16:58:23.459Z>\n## Google OAuth 로그인 구현 완료\n\nGoogle OAuth 로그인 기능을 성공적으로 구현하였습니다. 다음 기능을 개발하였습니다:\n\n1. **Google OAuth 인증 흐름 구현**:\n   - Google 소셜 로그인 설정 및 요청 처리 (`lib/supabase/social/google.ts`)\n   - OAuth 파라미터, 스코프, 액세스 타입 등 세부 설정 추가\n   - 토큰 교환 및 사용자 정보 획득 로직 구현\n\n2. **토큰 관리 및 프로필 처리**:\n   - ID 토큰 검증 및 파싱 기능 구현\n   - 사용자 프로필 정보 정규화 함수 추가\n   - 특별한 경우에 대한 토큰 교환 API 구현 (`app/api/auth/google/route.ts`)\n\n3. **사용자 프로필 통합**:\n   - Supabase `user_profiles` 테이블과 Google 프로필 연동\n   - 프로필 정보 업데이트 로직 구현\n   - 로그인 후 프로필 이미지, 이름 등 동기화\n\n4. **통합 서비스에 Google 인증 기능 추가**:\n   - 서비스 클래스에 Google 특화 프로필 처리 로직 추가\n   - 콜백 처리 과정에서 Google 사용자 정보 활용\n\nGoogle OAuth 흐름은 다음과 같이 동작합니다:\n1. 사용자가 Google 로그인 버튼 클릭\n2. `signInWithGoogleImpl` 함수가 호출되어 Supabase OAuth 요청 시작\n3. 사용자가 Google 로그인 페이지에서 인증\n4. 콜백 URL로 리디렉션 된 후 `handleCallback` 함수에서 처리\n5. ID 토큰으로부터 사용자 정보 추출 및 프로필 업데이트\n6. 사용자를 원래 페이지로 리디렉션\n\n이제 Google 계정으로 안전하게 로그인하고 사용자 프로필 정보를 가져올 수 있습니다.\n</info added on 2025-05-21T16:58:23.459Z>",
          "status": "done",
          "testStrategy": "테스트 계정으로 로그인 흐름 검증, 토큰 만료 및 갱신 시나리오 테스트"
        },
        {
          "id": 3,
          "title": "Apple Sign-In 로그인 구현",
          "description": "Apple Sign-In을 사용하여 사용자 인증 및 프로필 정보 가져오기 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. Apple Developer 계정에서 Sign-In 설정 및 인증서 생성\n2. 로그인 요청 및 콜백 처리 로직 구현\n3. JWT 토큰 검증 및 처리\n4. 제한된 사용자 정보 처리 방식 구현 (Apple은 이메일과 이름만 제공할 수 있음)\n5. 웹과 모바일 플랫폼 간 일관된 구현 보장\n<info added on 2025-05-21T17:01:59.070Z>\n구현 완료:\n\n1. Apple Sign-In 인증 흐름 구현:\n   - Apple 로그인 인증 요청 처리 (`lib/supabase/social/apple.ts`)\n   - Apple OAuth 파라미터, 스코프, 응답 모드 등 세부 설정\n   - 제한된 사용자 정보 처리를 위한 특별 로직\n\n2. 토큰 검증 및 관리:\n   - ID 토큰 파싱 및 검증 기능\n   - 사용자 프로필 정보 정규화\n   - JWT 라이브러리(jose)를 사용한 토큰 검증\n   - Apple 클라이언트 시크릿 생성 서버 측 로직 (`app/api/auth/apple/route.ts`)\n\n3. 최초 로그인 시 사용자 데이터 관리:\n   - 최초 로그인 시 제공되는 이름과 이메일 localStorage 저장 및 재사용\n   - 사용자 프로필 정보 저장 및 관리\n   - Supabase와 사용자 프로필 정보 통합\n\n4. 콜백 처리:\n   - Apple 특화 콜백 처리 로직 (`app/auth/callback/[provider]/page.tsx`)\n   - 콜백 URL 파라미터 처리 (user, state, id_token, code 등)\n   - 오류 처리 및 사용자 피드백\n\n인증 흐름: 로그인 버튼 클릭 → OAuth 요청 → Apple ID 인증 → 콜백 URL 리디렉션 → 파라미터 처리 → 사용자 정보 저장 → 원래 페이지로 리디렉션\n</info added on 2025-05-21T17:01:59.070Z>",
          "status": "done",
          "testStrategy": "iOS 및 웹 환경에서 로그인 테스트, 프라이빗 이메일 릴레이 처리 검증"
        },
        {
          "id": 4,
          "title": "Kakao 로그인 구현",
          "description": "Kakao OAuth를 사용하여 사용자 인증 및 프로필 정보 가져오기 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. Kakao Developer에서 앱 등록 및 API 키 발급\n2. 로그인 요청 및 콜백 처리 로직 구현\n3. 액세스 토큰 및 리프레시 토큰 관리\n4. 사용자 프로필 정보 가져오기 및 Supabase 사용자 데이터와 통합\n5. 필요한 추가 권한 스코프 설정 (프로필, 이메일 등)\n<info added on 2025-05-21T17:09:51.229Z>\n## 구현 완료 사항\n\n1. **Kakao OAuth 인증 흐름 구현**:\n   - Kakao 소셜 로그인 설정 및 요청 처리 (`lib/supabase/social/kakao.ts`)\n   - OAuth 파라미터, 스코프, 동의화면 설정 등 세부 설정 추가\n   - 토큰 교환 및 사용자 정보 획득 로직 구현\n\n2. **토큰 관리 및 프로필 처리**:\n   - 사용자 프로필 정보 정규화 함수 구현\n   - 프로필 정보 표준화 및 처리\n   - 액세스 토큰 및 갱신 토큰 관리 구현\n\n3. **API 엔드포인트 구현**:\n   - Kakao 토큰 및 사용자 정보 처리 API (`app/api/auth/kakao/route.ts`)\n   - 토큰 갱신 API 구현\n   - 오류 처리 및 응답 표준화\n\n4. **Supabase 사용자 통합**:\n   - Kakao 사용자 정보와 Supabase 사용자 프로필 연동\n   - Supabase Admin API 사용시 오류 수정 (getUserByEmail → listUsers)\n\n5. **보안 고려사항**:\n   - 토큰 검증 및 보안 처리\n   - 민감한 정보 관리\n</info added on 2025-05-21T17:09:51.229Z>",
          "status": "done",
          "testStrategy": "한국어 환경 및 글로벌 환경에서 로그인 테스트, 권한 동의 화면 검증"
        },
        {
          "id": 5,
          "title": "WeChat 로그인 구현",
          "description": "WeChat OAuth를 사용하여 사용자 인증 및 프로필 정보 가져오기 기능을 구현합니다.",
          "dependencies": [
            1
          ],
          "details": "1. WeChat 개발자 계정 설정 및 앱 ID 발급\n2. 로그인 요청 및 콜백 처리 로직 구현\n3. 액세스 토큰 및 리프레시 토큰 관리\n4. 사용자 프로필 정보 가져오기 및 Supabase 사용자 데이터와 통합\n5. 중국 사용자를 위한 특별 처리 로직 구현 (Great Firewall 고려)\n<info added on 2025-05-21T17:10:15.586Z>\n구현 완료 사항:\n\n1. **WeChat OAuth 인증 흐름 구현**:\n   - WeChat 소셜 로그인 설정 및 요청 처리 (`lib/supabase/social/wechat.ts`)\n   - OAuth 인증 경로 및 파라미터 구성\n   - 상태 토큰 생성 및 CSRF 보안 구현\n   - 브라우저 환경 검증 로직 추가 (WeChat 사용 가능 여부 확인)\n\n2. **토큰 관리 및 프로필 처리**:\n   - 사용자 프로필 정보 정규화 함수 구현\n   - 토큰 교환 및 관리 구현\n   - 오류 처리 로직 강화\n\n3. **API 엔드포인트 구현**:\n   - WeChat 콜백 처리 API (`app/api/auth/wechat/route.ts`)\n   - 액세스 토큰 획득 로직 구현\n   - 사용자 정보 요청 및 처리\n   - 토큰 갱신 API (PUT 메서드) 구현\n   - JWT 토큰 생성 기능 추가\n\n4. **Supabase 사용자 통합**:\n   - WeChat 사용자 정보와 Supabase 사용자 프로필 연동\n   - 기존 사용자 확인 및 프로필 업데이트 로직\n\n5. **특수 고려사항**:\n   - 중국 전용 API 엔드포인트 지원\n   - 언어 설정 및 인코딩 처리\n   - 오류 응답 및 메시지 표준화\n\n참고: 프로덕션 환경에서는 JWT 서명 등의 기능에 대해 더 안전한 구현이 필요함\n</info added on 2025-05-21T17:10:15.586Z>",
          "status": "done",
          "testStrategy": "중국 내/외부 환경에서 로그인 테스트, 중국어 문자 처리 검증"
        },
        {
          "id": 6,
          "title": "통합 사용자 데이터 관리 및 계정 연동 구현",
          "description": "다양한 소셜 로그인 제공자에서 가져온 사용자 데이터를 통합하고 기존 계정과의 연동 기능을 구현합니다.",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "1. 각 플랫폼에서 가져온 사용자 정보 표준화 로직 구현\n2. 이메일 중복 확인 및 계정 연동 프로세스 구현\n3. 사용자가 여러 소셜 계정을 하나의 앱 계정에 연결할 수 있는 기능 구현\n4. 프로필 정보 병합 및 업데이트 전략 구현\n5. 연결된 소셜 계정 관리 UI 구현",
          "status": "done",
          "testStrategy": "다중 소셜 계정 연동 시나리오 테스트, 계정 연결/해제 기능 검증"
        },
        {
          "id": 7,
          "title": "오류 처리, 보안 강화 및 성능 최적화",
          "description": "모든 소셜 로그인 통합에 대한 오류 처리, 보안 강화 및 성능 최적화를 구현합니다.",
          "dependencies": [
            6
          ],
          "details": "1. 모든 인증 실패 시나리오에 대한 통합 오류 처리 구현\n2. CSRF 방지 및 상태 토큰 검증 로직 구현\n3. 토큰 저장소 보안 강화 (암호화 저장, 안전한 접근 방식)\n4. 로그인 프로세스 성능 측정 및 최적화\n5. 사용자 경험 개선을 위한 로딩 상태 및 오류 메시지 표시 구현\n6. 모든 소셜 로그인 통합 테스트 및 문서화",
          "status": "done",
          "testStrategy": "보안 취약점 테스트, 오류 주입 테스트, 성능 벤치마킹, 다양한 네트워크 환경에서의 테스트"
        }
      ]
    },
    {
      "id": 17,
      "title": "AuthProvider 통합 및 인증 시스템 일관성 확보",
      "description": "두 개의 AuthProvider(contexts/AuthContext.tsx와 lib/supabase/auth-provider.tsx)를 통합하거나 하나를 선택하여 일관된 인증 시스템을 구축하고, 모든 컴포넌트가 동일한 AuthProvider를 사용하도록 업데이트하는 작업입니다.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "현재 애플리케이션에서는 두 개의 AuthProvider가 동시에 사용되고 있어 'useAuth must be used within an AuthProvider' 오류가 발생하고 있습니다:\n1. contexts/AuthContext.tsx의 기존 AuthProvider\n2. lib/supabase/auth-provider.tsx의 새 AuthProvider\n\n문제 상황:\n- app/[lang]/layout.tsx에서는 새 AuthProvider를 사용\n- components/layouts/Header.tsx에서는 기존 AuthProvider의 useAuth 훅을 사용\n\n해결 방안:\n1. 두 AuthProvider의 기능을 비교 분석하여 통합 가능성 평가\n2. 가능하면 하나의 통합된 AuthProvider 구현 (Supabase 기반 권장)\n3. 통합이 어렵다면 하나의 AuthProvider를 선택하고 다른 하나는 제거\n4. 선택된 AuthProvider를 사용하도록 모든 컴포넌트 업데이트\n5. 특히 components/layouts/Header.tsx의 useAuth 호출 부분 수정\n6. app/[lang]/layout.tsx에서 올바른 AuthProvider 사용 확인\n\n구현 시 고려사항:\n- 인증 상태 관리 일관성 유지\n- 로그인/로그아웃 기능 정상 작동 확인\n- 사용자 정보 접근 방식 통일\n- 소셜 로그인 확장 작업(#16)과의 호환성 확보\n- 기존 인증 관련 기능 손실 없이 마이그레이션\n\n우선순위: 높음(high)\n의존성: 소셜 로그인 기능 확장 작업(#16)의 선행 작업으로 지정",
      "testStrategy": "1. 코드 리뷰:\n   - 두 AuthProvider 중 하나가 제거되었거나 통합되었는지 확인\n   - 모든 컴포넌트가 동일한 AuthProvider를 참조하는지 검증\n   - 불필요한 코드가 제거되었는지 확인\n\n2. 기능 테스트:\n   - 로그인 프로세스 테스트 (이메일/비밀번호, 소셜 로그인)\n   - 로그아웃 기능 테스트\n   - 인증된 사용자만 접근 가능한 페이지 테스트\n   - 인증 상태 유지 및 새로고침 후 상태 복원 테스트\n\n3. 오류 테스트:\n   - 'useAuth must be used within an AuthProvider' 오류가 더 이상 발생하지 않는지 확인\n   - 콘솔에 인증 관련 오류가 없는지 확인\n   - 개발자 도구의 React DevTools를 사용하여 컴포넌트 트리에서 AuthProvider가 올바르게 구성되었는지 확인\n\n4. 통합 테스트:\n   - Header 컴포넌트가 인증 상태를 올바르게 표시하는지 확인\n   - 인증이 필요한 다른 컴포넌트들이 정상 작동하는지 확인\n   - 소셜 로그인 기능과의 호환성 테스트\n\n5. 성능 테스트:\n   - 인증 관련 작업 수행 시 불필요한 리렌더링이 발생하지 않는지 확인\n   - 인증 상태 변경 시 애플리케이션 반응 속도 측정",
      "subtasks": [
        {
          "id": 1,
          "title": "분석: 두 AuthProvider 코드 비교 및 통합 전략 수립",
          "description": "contexts/AuthContext.tsx와 lib/supabase/auth-provider.tsx의 코드를 분석하여 기능, 인터페이스, 의존성을 비교하고 통합 전략을 수립합니다.",
          "dependencies": [],
          "details": "1. 두 AuthProvider의 상태 관리 방식 비교\n2. 제공하는 메서드와 훅 인터페이스 분석\n3. Supabase 연동 방식 차이점 파악\n4. 각 Provider가 사용되는 컴포넌트 목록 작성\n5. 통합 또는 대체 전략 문서화(Supabase 기반 권장)\n6. 마이그레이션 계획 수립\n<info added on 2025-05-21T15:47:18.066Z>\n## 현재 인증 구조 분석\n\n1. 두 개의 AuthProvider가 존재함:\n   - contexts/AuthContext.tsx의 AuthProvider: 사용자 인증 상태, 로그인/로그아웃 관리\n   - lib/supabase/auth-provider.tsx의 AuthProvider: 새로운 Supabase SSR 인증 관리\n\n2. 세 개의 useAuth 훅이 존재함:\n   - contexts/AuthContext.tsx의 useAuth(): 기존 인증 상태 관리, 여러 컴포넌트에서 사용\n   - lib/supabase/auth-provider.tsx의 useAuth(): 새 AuthProvider에 대한 훅\n   - hooks/useAuth.ts의 useAuth(): 별도의 독립적인 훅으로 supabase 클라이언트 직접 사용\n\n3. 문제점:\n   - app/[lang]/layout.tsx는 lib/supabase/auth-provider.tsx의 AuthProvider를 사용\n   - 여러 컴포넌트(Header, Mypage 등)는 contexts/AuthContext.tsx의 useAuth 훅 사용\n   - VoteDetailContent는 hooks/useAuth.ts의 독립 훅 사용\n   - 일관성 없는 사용으로 'useAuth must be used within an AuthProvider' 오류 발생\n\n4. Supabase 클라이언트:\n   - utils/supabase-client.ts: 브라우저용 클라이언트\n   - utils/supabase-server-client.ts: 서버용 클라이언트\n   - utils/api/auth.ts: supabase-client를 재노출\n\n## 해결 전략\n1. lib/supabase/auth-provider.tsx 기반으로 통합 AuthProvider 구현 (이는 SSR과 최신 Supabase 클라이언트 사용)\n2. 모든 useAuth 훅을 통합 Provider와 호환되도록 수정\n3. contexts/AuthContext.tsx는 폐지하고 관련 함수는 마이그레이션\n4. 컴포넌트에서 일관된 useAuth 훅 사용으로 변경\n</info added on 2025-05-21T15:47:18.066Z>",
          "status": "done",
          "testStrategy": "코드 분석 결과와 통합 전략을 문서화하여 리뷰"
        },
        {
          "id": 2,
          "title": "통합 AuthProvider 인터페이스 설계 및 구현",
          "description": "분석 결과를 바탕으로 통합된 AuthProvider를 설계하고 구현합니다. Supabase 기반으로 기존 기능을 모두 지원하는 단일 AuthProvider를 개발합니다.",
          "dependencies": [
            1
          ],
          "details": "1. lib/supabase/auth-provider.tsx를 기반으로 통합 AuthProvider 구현\n2. contexts/AuthContext.tsx의 필수 기능 통합\n3. useAuth 훅 인터페이스 일관성 유지\n4. 사용자 인증 상태, 로그인/로그아웃, 사용자 정보 접근 메서드 구현\n5. 타입 정의 업데이트\n6. 소셜 로그인 확장성 고려\n<info added on 2025-05-21T15:48:17.251Z>\n### 통합 AuthProvider 인터페이스 분석 및 설계\n\n두 AuthProvider 비교 분석 결과:\n\n1. **lib/supabase/auth-provider.tsx**\n   - **장점**: NextJS 13+ App Router 및 SSR/RSC 지원, 최신 supabase 클라이언트 사용\n   - **인터페이스**: user, session, isLoading, isAuthenticated, signIn, signInWithOAuth, signUp, signOut, refreshSession 제공\n   - **타입**: Session, User 등 Supabase 타입 직접 사용\n\n2. **contexts/AuthContext.tsx**\n   - **장점**: 상세한 사용자 프로필 관리, 로컬 스토리지 관리, 쿠키 관리\n   - **인터페이스**: authState(isAuthenticated, user, loading, error), signIn, signInWithSocial, signOut, signUp, updateUserProfile 제공\n   - **타입**: UserProfiles 인터페이스 사용, 사용자 메타데이터 관리\n\n3. **hooks/useAuth.ts**\n   - **장점**: 간단한 사용법, 독립적인 인증 상태 관리\n   - **인터페이스**: isAuthenticated, isLoading만 제공\n\n### 통합 인터페이스 설계:\n\n1. **통합 AuthContext 인터페이스**:\n```typescript\ninterface AuthContextType {\n  // 기본 인증 상태\n  user: User | null;\n  userProfile: UserProfiles | null;\n  session: Session | null;\n  isLoading: boolean;\n  isAuthenticated: boolean;\n  error: string | null;\n  \n  // 인증 메서드\n  signIn: (email: string, password: string) => Promise<{ error: Error | null }>;\n  signInWithOAuth: (provider: 'google' | 'apple' | 'kakao' | 'wechat') => Promise<{ error: Error | null }>;\n  signUp: (email: string, password: string, username?: string) => Promise<{ error: Error | null, data: { user: User | null } }>;\n  signOut: () => Promise<{ success: boolean; error?: unknown }>;\n  refreshSession: () => Promise<void>;\n  \n  // 프로필 관리\n  updateUserProfile: (profile: Partial<UserProfiles>) => Promise<{ success: boolean; error?: unknown }>;\n}\n```\n\n2. **구현 전략**:\n   - `lib/supabase/auth-provider.tsx`의 최신 Supabase 클라이언트 활용 (SSR 지원)\n   - `contexts/AuthContext.tsx`의 사용자 프로필 관리 로직 포함\n   - 에러 처리 통합 (contexts/AuthContext.tsx 기반)\n   - Social 로그인 확장 (google, apple, kakao, wechat 지원)\n   - WeChat 지원 추가\n\n3. **기존 컴포넌트 마이그레이션 계획**:\n   - Header.tsx: contexts/AuthContext의 useAuth에서 신규 useAuth로 전환\n   - VoteDetailContent.tsx: hooks/useAuth.ts에서 신규 useAuth로 전환\n   - app/[lang]/(mypage)/mypage/page.tsx: contexts/AuthContext의 useAuth에서 신규 useAuth로 전환\n   - app/[lang]/(main)/layout.tsx: contexts/AuthContext의 useAuth에서 신규 useAuth로 전환\n</info added on 2025-05-21T15:48:17.251Z>",
          "status": "done",
          "testStrategy": "단위 테스트로 AuthProvider의 주요 기능 검증, 특히 로그인/로그아웃 및 상태 관리 테스트"
        },
        {
          "id": 3,
          "title": "레이아웃 컴포넌트 마이그레이션",
          "description": "app/[lang]/layout.tsx와 components/layouts/Header.tsx 등 레이아웃 관련 컴포넌트를 통합된 AuthProvider를 사용하도록 업데이트합니다.",
          "dependencies": [
            2
          ],
          "details": "1. app/[lang]/layout.tsx에서 AuthProvider 사용 방식 업데이트\n2. components/layouts/Header.tsx의 useAuth 호출 수정\n3. 레이아웃 관련 다른 컴포넌트 확인 및 업데이트\n4. 인증 상태에 따른 UI 렌더링 로직 검증\n5. 네비게이션 및 권한 관련 로직 업데이트\n<info added on 2025-05-21T15:52:48.981Z>\n마이그레이션 작업 완료:\n\n1. components/layouts/Header.tsx\n   - contexts/AuthContext에서 lib/supabase/auth-provider로 import 변경\n   - authState.isAuthenticated에서 isAuthenticated 직접 사용으로 변경\n   - authState.user 대신 userProfile 사용\n\n2. app/[lang]/layout.tsx\n   - 이미 새 AuthProvider 사용 중 확인\n\n3. app/[lang]/(main)/layout.tsx\n   - AuthContext에서 lib/supabase/auth-provider로 import 변경\n   - 통합된 훅 사용하도록 수정\n\n4. app/[lang]/(mypage)/mypage/page.tsx\n   - user 참조를 userProfile로 변경\n   - authState.loading을 isLoading으로 변경\n   - 인증 관련 로직 업데이트\n\n5. hooks/useAuth.ts\n   - 기존 구현 제거\n   - lib/supabase/auth-provider에서 내보내는 useAuth 직접 재내보내기로 변경\n\n마이그레이션 확인 사항:\n- 주요 useAuth 사용 컴포넌트들이 새 provider 사용하도록 업데이트 완료\n- 기존 AuthContext 의존 컴포넌트들의 호환성 유지\n- 백워드 호환성을 위해 hooks/useAuth.ts 유지 및 재내보내기 패턴 적용\n</info added on 2025-05-21T15:52:48.981Z>",
          "status": "done",
          "testStrategy": "개발 환경에서 레이아웃 컴포넌트의 렌더링 및 인증 상태 반영 테스트"
        },
        {
          "id": 4,
          "title": "인증 관련 기능 컴포넌트 마이그레이션",
          "description": "로그인, 회원가입, 프로필 등 인증 관련 기능을 사용하는 모든 컴포넌트를 통합된 AuthProvider를 사용하도록 업데이트합니다.",
          "dependencies": [
            2
          ],
          "details": "1. 로그인/회원가입 폼 컴포넌트 업데이트\n2. 프로필 관리 컴포넌트 업데이트\n3. 인증이 필요한 페이지 및 컴포넌트 식별 및 수정\n4. 권한 검사 로직 업데이트\n5. 리다이렉션 로직 검증\n6. 에러 처리 및 사용자 피드백 메커니즘 확인\n<info added on 2025-05-21T15:56:26.811Z>\n7. AuthProvider 테스트 및 검증\n   - 디버깅 로그 추가 (인증 이벤트, 상태 변경, 오류 정보)\n   - tests/auth-provider-test.tsx 테스트 컴포넌트 구현\n   - app/test-auth/page.tsx 테스트 페이지 생성\n   - 인증 상태, 로그인/로그아웃, 소셜 로그인, 오류 핸들링 검증\n   - 개발 환경 전용 테스트 페이지 접근 제한 설정\n</info added on 2025-05-21T15:56:26.811Z>",
          "status": "done",
          "testStrategy": "주요 인증 플로우(로그인, 로그아웃, 회원가입, 권한 검사)에 대한 통합 테스트"
        },
        {
          "id": 5,
          "title": "테스트, 정리 및 문서화",
          "description": "통합된 인증 시스템을 전체적으로 테스트하고, 불필요한 코드를 제거하며, 변경사항을 문서화합니다.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. 전체 인증 플로우 테스트(로그인, 로그아웃, 세션 유지 등)\n2. 사용하지 않는 AuthProvider 코드 제거(contexts/AuthContext.tsx)\n3. 불필요한 import 및 의존성 정리\n4. 인증 관련 에러 메시지 확인 및 개선\n5. README 또는 개발 문서 업데이트\n6. 소셜 로그인 확장 작업(#16)과의 호환성 최종 확인\n<info added on 2025-05-21T15:57:00.831Z>\n7. 통합 AuthProvider 구현 결과\n   - lib/supabase/auth-provider.tsx 확장으로 통합된 인증 인터페이스 구축\n   - 모든 소셜 로그인 플랫폼(Google, Apple, Kakao, WeChat) 지원 체계 마련\n   - 사용자 및 프로필 정보의 통합적 관리 구현\n   - 단일 useAuth 훅을 통한 모든 인증 기능 접근 가능\n   - \"useAuth must be used within an AuthProvider\" 오류 해결\n   - 모든 주요 컴포넌트의 새 AuthProvider 사용 적용 완료\n   - 기존 AuthContext는 deprecated 표시 및 참조용으로 유지\n   - Supabase 최신 인증 기능 활용한 보안 강화\n   - 세션 관리 및 오류 처리 메커니즘 개선\n</info added on 2025-05-21T15:57:00.831Z>",
          "status": "done",
          "testStrategy": "다양한 브라우저 환경에서 E2E 테스트 수행, 특히 인증 상태 유지 및 페이지 새로고침 시나리오 검증"
        }
      ]
    }
  ]
}