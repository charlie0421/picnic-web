#!/usr/bin/env node

/**
 * RLS Ï†ïÏ±Ö Ï†ÅÏö© Ïä§ÌÅ¨Î¶ΩÌä∏
 * 
 * Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî Ï§ëÏöîÌïú ÌÖåÏù¥Î∏îÎì§Ïóê ÎåÄÌï¥ RLS Ï†ïÏ±ÖÏùÑ Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Ï†ÅÏö©Ìï©ÎãàÎã§.
 * Supabase DashboardÏùò SQL EditorÏóêÏÑú Ïã§ÌñâÌï† Ïàò ÏûàÎäî SQL Î¨∏ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

/**
 * RLS Ï†ïÏ±Ö Ï†ÅÏö© Î∞è Í≤ÄÏ¶ù
 */
async function applyRLSPolicies() {
  console.log('üîê [RLS] RLS Ï†ïÏ±Ö Ï†ÅÏö© Î∞è Í≤ÄÏ¶ù ÏãúÏûë...');

  // ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !serviceRoleKey) {
    console.error('‚ùå [RLS] ÌïÑÏöîÌïú ÌôòÍ≤Ω Î≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§:');
    console.error('- NEXT_PUBLIC_SUPABASE_URL:', supabaseUrl ? '‚úÖ ÏÑ§Ï†ïÎê®' : '‚ùå ÏóÜÏùå');
    console.error('- SUPABASE_SERVICE_ROLE_KEY:', serviceRoleKey ? '‚úÖ ÏÑ§Ï†ïÎê®' : '‚ùå ÏóÜÏùå');
    console.log('\nüí° [RLS] .env ÌååÏùºÏóê Îã§Ïùå Î≥ÄÏàòÎì§ÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî:');
    console.log('NEXT_PUBLIC_SUPABASE_URL=your_supabase_url');
    console.log('SUPABASE_SERVICE_ROLE_KEY=your_service_role_key');
    process.exit(1);
  }

  // Service Role ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
  const supabase = createClient(supabaseUrl, serviceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  });

  try {
    // ÌòÑÏû¨ RLS ÏÉÅÌÉú ÌôïÏù∏
    console.log('\nüîç [RLS] ÌòÑÏû¨ RLS ÏÉÅÌÉú ÌôïÏù∏...');
    await checkCurrentRLSStatus(supabase);

    // SQL Ïä§ÌÅ¨Î¶ΩÌä∏ ÌååÏùº ÏÉùÏÑ±
    console.log('\nüìù [RLS] SQL Ïä§ÌÅ¨Î¶ΩÌä∏ ÌååÏùº ÏÉùÏÑ±...');
    await generateApplicableSQL();

    // Helper Ìï®Ïàò ÌôïÏù∏
    console.log('\nÔøΩ [RLS] Helper Ìï®Ïàò ÌôïÏù∏...');
    await checkHelperFunctions(supabase);

    console.log('\n‚úÖ [RLS] RLS Ï†ïÏ±Ö Ï§ÄÎπÑ ÏôÑÎ£å!');
    console.log('\nÔøΩ [RLS] Îã§Ïùå Îã®Í≥ÑÎ•º Îî∞ÎùºÏ£ºÏÑ∏Ïöî:');
    console.log('1. scripts/apply-rls-policies.sql ÌååÏùºÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.');
    console.log('2. Supabase Dashboard > SQL EditorÎ°ú Ïù¥ÎèôÌïòÏÑ∏Ïöî.');
    console.log('3. ÏÉùÏÑ±Îêú SQL ÌååÏùºÏùò ÎÇ¥Ïö©ÏùÑ Î≥µÏÇ¨ÌïòÏó¨ Ïã§ÌñâÌïòÏÑ∏Ïöî.');
    console.log('4. Ïã§Ìñâ ÌõÑ Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Îã§Ïãú Ïã§ÌñâÌïòÏó¨ Ï†ÅÏö© ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.');

  } catch (error) {
    console.error('‚ùå [RLS] RLS Ï†ïÏ±Ö Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', error);
    process.exit(1);
  }
}

/**
 * ÌòÑÏû¨ RLS ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkCurrentRLSStatus(supabase) {
  const criticalTables = [
    'user_profiles',
    'vote_pick', 
    'vote_comment',
    'vote_comment_like',
    'vote_comment_report',
    'vote',
    'vote_item',
    'artist',
    'artist_group',
    'vote_share_bonus'
  ];

  console.log('ÔøΩ [RLS] Ï§ëÏöî ÌÖåÏù¥Î∏îÎì§Ïùò ÌòÑÏû¨ RLS ÏÉÅÌÉú:');
  
  for (const tableName of criticalTables) {
    try {
      const { data, error } = await supabase
        .from('pg_tables')
        .select('tablename, rowsecurity')
        .eq('tablename', tableName)
        .single();

      if (error) {
        console.log(`   ${tableName}: ‚ùì ÌôïÏù∏ Î∂àÍ∞Ä (${error.message})`);
      } else if (data) {
        const status = data.rowsecurity ? '‚úÖ RLS ÌôúÏÑ±ÌôîÎê®' : '‚ùå RLS ÎπÑÌôúÏÑ±ÌôîÎê®';
        console.log(`   ${tableName}: ${status}`);
      } else {
        console.log(`   ${tableName}: ‚ùì ÌÖåÏù¥Î∏î ÏóÜÏùå`);
      }
    } catch (err) {
      console.log(`   ${tableName}: ‚ùì ÌôïÏù∏ Ïò§Î•ò (${err.message})`);
    }
  }

  // Í∏∞Ï°¥ Ï†ïÏ±Ö Í∞úÏàò ÌôïÏù∏
  try {
    const { data: policies, error: policiesError } = await supabase
      .from('pg_policies')
      .select('tablename, policyname')
      .in('tablename', criticalTables);

    if (!policiesError && policies) {
      console.log(`\nüìã [RLS] ÌòÑÏû¨ Ï†ÅÏö©Îêú Ï†ïÏ±Ö Í∞úÏàò: ${policies.length}Í∞ú`);
      
      const policiesByTable = policies.reduce((acc, policy) => {
        acc[policy.tablename] = (acc[policy.tablename] || 0) + 1;
        return acc;
      }, {});

      Object.entries(policiesByTable).forEach(([table, count]) => {
        console.log(`   ${table}: ${count}Í∞ú Ï†ïÏ±Ö`);
      });
    }
  } catch (err) {
    console.log('‚ö†Ô∏è [RLS] Í∏∞Ï°¥ Ï†ïÏ±Ö Ï°∞Ìöå Ïã§Ìå®:', err.message);
  }
}

/**
 * Helper Ìï®Ïàò ÌôïÏù∏
 */
async function checkHelperFunctions(supabase) {
  const helperFunctions = [
    { name: 'is_admin', params: {} },
    { name: 'owns_resource', params: { resource_user_id: 'test-user' } }
  ];
  
  for (const { name, params } of helperFunctions) {
    try {
      const { data, error } = await supabase.rpc(name, params);
      
      if (error) {
        console.log(`   ${name}: ‚ùå Ìï®Ïàò ÏóÜÏùå (${error.message})`);
      } else {
        console.log(`   ${name}: ‚úÖ Ìï®Ïàò Ï°¥Ïû¨ÌïòÍ≥† ÏûëÎèôÌï®`);
      }
    } catch (err) {
      console.log(`   ${name}: ‚ùå Ìï®Ïàò ÌÖåÏä§Ìä∏ Ïã§Ìå® (${err.message})`);
    }
  }
}

/**
 * Ïã§Ìñâ Í∞ÄÎä•Ìïú SQL Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±
 */
async function generateApplicableSQL() {
  const sqlFilePath = path.join(__dirname, 'apply-rls-policies.sql');
  
  const sqlContent = `-- Picnic Application RLS Policies Application Script
-- Generated automatically - Execute this in Supabase SQL Editor
-- =====================================================

-- 1. Enable RLS on all critical tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_pick ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_comment ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_comment_like ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_comment_report ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_item ENABLE ROW LEVEL SECURITY;
ALTER TABLE artist ENABLE ROW LEVEL SECURITY;
ALTER TABLE artist_group ENABLE ROW LEVEL SECURITY;

-- 2. Helper Functions
CREATE OR REPLACE FUNCTION auth.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN (
        SELECT COALESCE(is_admin, false)
        FROM user_profiles
        WHERE id = auth.uid()
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION auth.owns_resource(resource_user_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN auth.uid()::text = resource_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Grant permissions
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT EXECUTE ON FUNCTION auth.is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION auth.owns_resource(TEXT) TO authenticated;

-- 4. USER_PROFILES policies
DROP POLICY IF EXISTS "user_profiles_select_own" ON user_profiles;
CREATE POLICY "user_profiles_select_own" ON user_profiles
    FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "user_profiles_select_admin" ON user_profiles;
CREATE POLICY "user_profiles_select_admin" ON user_profiles
    FOR SELECT USING (auth.is_admin());

DROP POLICY IF EXISTS "user_profiles_update_own" ON user_profiles;
CREATE POLICY "user_profiles_update_own" ON user_profiles
    FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS "user_profiles_update_admin" ON user_profiles;
CREATE POLICY "user_profiles_update_admin" ON user_profiles
    FOR UPDATE USING (auth.is_admin());

DROP POLICY IF EXISTS "user_profiles_insert_own" ON user_profiles;
CREATE POLICY "user_profiles_insert_own" ON user_profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- 5. VOTE_PICK policies
DROP POLICY IF EXISTS "vote_pick_select_own" ON vote_pick;
CREATE POLICY "vote_pick_select_own" ON vote_pick
    FOR SELECT USING (auth.uid()::text = user_id::text);

DROP POLICY IF EXISTS "vote_pick_select_admin" ON vote_pick;
CREATE POLICY "vote_pick_select_admin" ON vote_pick
    FOR SELECT USING (auth.is_admin());

DROP POLICY IF EXISTS "vote_pick_insert_own" ON vote_pick;
CREATE POLICY "vote_pick_insert_own" ON vote_pick
    FOR INSERT WITH CHECK (
        auth.uid()::text = user_id::text
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "vote_pick_insert_admin" ON vote_pick;
CREATE POLICY "vote_pick_insert_admin" ON vote_pick
    FOR INSERT WITH CHECK (auth.is_admin());

DROP POLICY IF EXISTS "vote_pick_update_own" ON vote_pick;
CREATE POLICY "vote_pick_update_own" ON vote_pick
    FOR UPDATE USING (
        auth.uid()::text = user_id::text
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "vote_pick_update_admin" ON vote_pick;
CREATE POLICY "vote_pick_update_admin" ON vote_pick
    FOR UPDATE USING (auth.is_admin());

-- 6. VOTE_COMMENT policies
DROP POLICY IF EXISTS "vote_comment_select_all" ON vote_comment;
CREATE POLICY "vote_comment_select_all" ON vote_comment
    FOR SELECT USING (
        auth.uid() IS NOT NULL 
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "vote_comment_insert_auth" ON vote_comment;
CREATE POLICY "vote_comment_insert_auth" ON vote_comment
    FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

DROP POLICY IF EXISTS "vote_comment_update_own" ON vote_comment;
CREATE POLICY "vote_comment_update_own" ON vote_comment
    FOR UPDATE USING (
        auth.uid()::text = user_id::text
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "vote_comment_update_admin" ON vote_comment;
CREATE POLICY "vote_comment_update_admin" ON vote_comment
    FOR UPDATE USING (auth.is_admin());

-- 7. PUBLIC TABLES (READ-ONLY for regular users)
DROP POLICY IF EXISTS "vote_select_all" ON vote;
CREATE POLICY "vote_select_all" ON vote
    FOR SELECT USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "vote_modify_admin" ON vote;
CREATE POLICY "vote_modify_admin" ON vote
    FOR ALL USING (auth.is_admin());

DROP POLICY IF EXISTS "vote_item_select_all" ON vote_item;
CREATE POLICY "vote_item_select_all" ON vote_item
    FOR SELECT USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "vote_item_modify_admin" ON vote_item;
CREATE POLICY "vote_item_modify_admin" ON vote_item
    FOR ALL USING (auth.is_admin());

DROP POLICY IF EXISTS "artist_select_all" ON artist;
CREATE POLICY "artist_select_all" ON artist
    FOR SELECT USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "artist_modify_admin" ON artist;
CREATE POLICY "artist_modify_admin" ON artist
    FOR ALL USING (auth.is_admin());

DROP POLICY IF EXISTS "artist_group_select_all" ON artist_group;
CREATE POLICY "artist_group_select_all" ON artist_group
    FOR SELECT USING (deleted_at IS NULL);

DROP POLICY IF EXISTS "artist_group_modify_admin" ON artist_group;
CREATE POLICY "artist_group_modify_admin" ON artist_group
    FOR ALL USING (auth.is_admin());

-- 8. VOTE_COMMENT_LIKE policies
DROP POLICY IF EXISTS "vote_comment_like_select_all" ON vote_comment_like;
CREATE POLICY "vote_comment_like_select_all" ON vote_comment_like
    FOR SELECT USING (auth.uid() IS NOT NULL);

DROP POLICY IF EXISTS "vote_comment_like_insert_own" ON vote_comment_like;
CREATE POLICY "vote_comment_like_insert_own" ON vote_comment_like
    FOR INSERT WITH CHECK (auth.uid()::text = user_id::text);

DROP POLICY IF EXISTS "vote_comment_like_delete_own" ON vote_comment_like;
CREATE POLICY "vote_comment_like_delete_own" ON vote_comment_like
    FOR DELETE USING (auth.uid()::text = user_id::text);

-- 9. VOTE_COMMENT_REPORT policies
DROP POLICY IF EXISTS "vote_comment_report_select_own" ON vote_comment_report;
CREATE POLICY "vote_comment_report_select_own" ON vote_comment_report
    FOR SELECT USING (auth.uid()::text = user_id::text);

DROP POLICY IF EXISTS "vote_comment_report_select_admin" ON vote_comment_report;
CREATE POLICY "vote_comment_report_select_admin" ON vote_comment_report
    FOR SELECT USING (auth.is_admin());

DROP POLICY IF EXISTS "vote_comment_report_insert_auth" ON vote_comment_report;
CREATE POLICY "vote_comment_report_insert_auth" ON vote_comment_report
    FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

-- Completed! 
-- Please verify the policies were applied correctly by running:
-- SELECT schemaname, tablename, rowsecurity FROM pg_tables 
-- WHERE tablename IN ('user_profiles', 'vote_pick', 'vote_comment', 'vote', 'vote_item', 'artist', 'artist_group');
`;

  fs.writeFileSync(sqlFilePath, sqlContent, 'utf8');
  console.log(`üìÅ [RLS] SQL Ïä§ÌÅ¨Î¶ΩÌä∏ ÌååÏùº ÏÉùÏÑ±Îê®: ${sqlFilePath}`);
}

/**
 * Ï†ÅÏö© ÌõÑ Í≤ÄÏ¶ù Ìï®Ïàò
 */
async function verifyRLSApplication() {
  console.log('üîç [RLS] RLS Ï†ïÏ±Ö Ï†ÅÏö© Í≤ÄÏ¶ù ÏãúÏûë...');

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !serviceRoleKey) {
    console.error('‚ùå [RLS] ÌôòÍ≤Ω Î≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    process.exit(1);
  }

  const supabase = createClient(supabaseUrl, serviceRoleKey, {
    auth: { autoRefreshToken: false, persistSession: false }
  });

  await checkCurrentRLSStatus(supabase);
  await checkHelperFunctions(supabase);

  console.log('\n‚úÖ [RLS] RLS Ï†ïÏ±Ö Í≤ÄÏ¶ù ÏôÑÎ£å!');
}

// Î™ÖÎ†πÌñâ Ïù∏Ïàò Ï≤òÎ¶¨
const args = process.argv.slice(2);
const command = args[0];

if (command === 'verify') {
  verifyRLSApplication()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('‚ùå [RLS] Í≤ÄÏ¶ù Ïã§Ìå®:', error);
      process.exit(1);
    });
} else if (require.main === module) {
  applyRLSPolicies()
    .then(() => {
      console.log('\nüí° [RLS] ÌåÅ: Ï†ïÏ±Ö Ï†ÅÏö© ÌõÑ Í≤ÄÏ¶ùÌïòÎ†§Î©¥ Îã§Ïùå Î™ÖÎ†πÏñ¥Î•º Ïã§ÌñâÌïòÏÑ∏Ïöî:');
      console.log('node scripts/apply-rls-policies.js verify');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå [RLS] Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ Ïã§Ìå®:', error);
      process.exit(1);
    });
}

module.exports = { applyRLSPolicies, verifyRLSApplication };