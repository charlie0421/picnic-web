{
  "metadata": {
    "version": "1.0.0",
    "project": "picnic-web",
    "tags": {
      "master": {
        "name": "master",
        "description": "Default task context",
        "created": "2024-12-27",
        "active": true
      }
    },
    "currentTag": "master"
  },
  "tags": {
    "master": {
      "tasks": []
    }
  },
  "payment-feature": {
    "tasks": [
      {
        "id": 1,
        "title": "Supabase Products Table Migration for Web Product Information",
        "description": "Migrate the Supabase products table by adding new fields to support web product information including web_price_krw, web_price_usd, web_bonus_amount, and other related fields.",
        "details": "This task involves extending the existing products table in Supabase to include additional fields necessary for displaying and managing web product information:\n\n1. Connect to the Supabase project and access the database using the Supabase dashboard or CLI.\n\n2. Create a migration script that adds the following fields to the products table:\n   - web_price_krw (integer or decimal): Price in Korean Won for web display\n   - web_price_usd (integer or decimal): Price in US Dollars for web display\n   - web_bonus_amount (integer or decimal): Bonus amount offered with the product\n   - web_display_order (integer): Order for displaying products on the web interface\n   - web_is_featured (boolean): Flag to mark featured products\n   - web_description (text): Detailed product description for web display\n\n3. Ensure proper data types and constraints:\n   - Add appropriate NOT NULL constraints where needed\n   - Set default values where appropriate (e.g., web_is_featured = false)\n   - Consider adding check constraints for price fields (must be positive)\n\n4. Update any existing database triggers or functions that interact with the products table.\n\n5. If there are existing products, consider how to handle the new fields for those records (default values or manual updates).\n\n6. Update database documentation to reflect the new schema.\n\n7. Coordinate with the frontend team to ensure they're aware of the new fields and how to use them.\n\nImplementation example:\n```sql\n-- Migration SQL\nALTER TABLE products\nADD COLUMN web_price_krw INTEGER,\nADD COLUMN web_price_usd DECIMAL(10,2),\nADD COLUMN web_bonus_amount INTEGER,\nADD COLUMN web_display_order INTEGER DEFAULT 999,\nADD COLUMN web_is_featured BOOLEAN DEFAULT false,\nADD COLUMN web_description TEXT;\n\n-- Optional: Add constraints\nALTER TABLE products\nADD CONSTRAINT check_web_price_krw_positive CHECK (web_price_krw > 0),\nADD CONSTRAINT check_web_price_usd_positive CHECK (web_price_usd > 0),\nADD CONSTRAINT check_web_bonus_amount_positive CHECK (web_bonus_amount >= 0);\n```",
        "testStrategy": "1. Execute the migration in a development/staging environment first to verify it runs without errors.\n\n2. Verify the schema changes:\n   - Connect to the database and run `\\d products` (PostgreSQL) to confirm all new columns are added with correct data types and constraints.\n   - Check that any default values are correctly applied.\n\n3. Test data manipulation:\n   - Insert a new product record with values for all the new fields.\n   - Update an existing product to include values for the new fields.\n   - Verify both operations succeed without errors.\n\n4. Test constraints:\n   - Attempt to insert negative values for price fields to ensure constraints are working.\n   - Test the behavior of NULL values where appropriate.\n\n5. Integration testing:\n   - If there are API endpoints that interact with the products table, test them to ensure they handle the new fields correctly.\n   - Verify that any ORM models or data access layers are updated to include the new fields.\n\n6. UI testing:\n   - If applicable, verify that the web interface correctly displays the new product information.\n   - Test sorting/filtering based on the new fields.\n\n7. Performance testing:\n   - For large tables, verify that the migration completes within an acceptable timeframe.\n   - Check if any indexes need to be added for query performance.\n\n8. Rollback testing:\n   - Prepare and test a rollback script in case the migration needs to be reversed.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Star Candy Recharge Page UI",
        "description": "Create the UI for the Star Candy recharge page by adding a 'Star Candy Recharge' menu item to the voting menu, implementing a product list page, and designing the web interface based on the existing app UI.",
        "details": "This task involves implementing the UI components for the Star Candy recharge functionality in the web application:\n\n1. Add a new menu item to the voting section:\n   - Locate the voting menu component in the navigation structure\n   - Add a new menu item labeled \"별사탕 충전\" (Star Candy Recharge)\n   - Ensure proper styling consistent with other menu items\n   - Link the menu item to the new product list page route\n\n2. Create the product list page:\n   - Implement a new route for the product list page (e.g., `/star-candy/products`)\n   - Design a responsive grid or list layout to display available Star Candy packages\n   - Each product card should display:\n     - Product name/title\n     - Star Candy amount\n     - Bonus amount (if applicable)\n     - Price in KRW and USD (using the web_price fields from the products table)\n     - Purchase button\n\n3. Design considerations:\n   - Reference the existing app UI for visual consistency while adapting for web\n   - Ensure responsive design that works on desktop and mobile browsers\n   - Use existing design system components (buttons, cards, typography) for consistency\n   - Implement appropriate loading states when fetching product data\n   - Add empty state handling if no products are available\n\n4. Implement basic interaction:\n   - Add hover/focus states for product cards\n   - Implement click handlers for the purchase buttons (actual purchase functionality will be implemented in a separate task)\n\n5. Fetch product data:\n   - Create a service function to retrieve product information from the Supabase products table\n   - Display products using the web-specific fields (web_price_krw, web_price_usd, web_bonus_amount)",
        "testStrategy": "1. Visual verification:\n   - Verify the \"별사탕 충전\" menu item appears correctly in the voting menu\n   - Confirm the menu item links to the correct product list page\n   - Check that the product list page layout matches the design requirements\n   - Verify responsive behavior on different screen sizes (desktop, tablet, mobile)\n\n2. Functional testing:\n   - Verify navigation from the menu item to the product list page works correctly\n   - Confirm product data is correctly fetched and displayed\n   - Test that all product information (prices, amounts) is displayed correctly\n   - Verify hover/focus states work as expected\n\n3. Cross-browser testing:\n   - Test the UI in Chrome, Firefox, Safari, and Edge\n   - Verify consistent appearance and functionality across browsers\n\n4. Accessibility testing:\n   - Verify proper focus management for keyboard navigation\n   - Check that all interactive elements have appropriate ARIA attributes\n   - Test with screen readers to ensure the UI is accessible\n\n5. Data validation:\n   - Test with various product data scenarios (different prices, bonus amounts)\n   - Verify empty state handling when no products are available\n   - Test with mock data to ensure UI handles different data formats correctly",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement IP-Based Payment Method Selection Logic",
        "description": "Develop logic to automatically select payment methods based on user IP address, showing Port One for Korean users and PayPal for international users, with an option to manually switch between payment methods.",
        "details": "This task involves implementing the IP-based payment method selection logic for the Star Candy recharge functionality:\n\n1. IP Detection Implementation:\n   - Integrate a reliable IP geolocation service (e.g., ipapi, ip-api, or MaxMind GeoIP)\n   - Implement a service that detects the user's IP address and determines their country\n   - Create a caching mechanism to avoid repeated lookups for the same user session\n\n2. Payment Method Selection Logic:\n   - Create a PaymentMethodSelector component/service that:\n     - Takes the country information as input\n     - Returns the appropriate payment method (Port One for Korea, PayPal for international)\n     - Includes default fallback logic if geolocation fails\n   - Implement the logic to display the correct payment UI based on the selected method\n\n3. Manual Override Implementation:\n   - Add a toggle or dropdown component allowing users to manually switch between payment methods\n   - Design the UI element to be intuitive and accessible (e.g., \"Switch to PayPal\" / \"Switch to Port One\")\n   - Ensure the manual selection persists during the session\n   - Consider adding a user preference setting to remember the manual choice\n\n4. Integration with Product Display:\n   - Modify the product list page to show prices in the appropriate currency based on the selected payment method\n   - Ensure the product information from the Supabase products table (web_price_krw, web_price_usd) is used correctly\n   - Update the UI to reflect the currently selected payment method\n\n5. Error Handling:\n   - Implement robust error handling for cases where IP detection fails\n   - Create fallback mechanisms to ensure users can always access at least one payment method\n   - Add appropriate logging for troubleshooting payment method selection issues\n\n6. Performance Considerations:\n   - Ensure the IP detection doesn't significantly impact page load times\n   - Consider performing the detection asynchronously after initial page render\n   - Implement appropriate loading states while detection is in progress",
        "testStrategy": "1. Unit Testing:\n   - Write unit tests for the IP detection service with mock IP addresses from different countries\n   - Test the PaymentMethodSelector logic with various country inputs\n   - Verify the manual override functionality works correctly in isolation\n\n2. Integration Testing:\n   - Test the integration between the IP detection and payment method selection\n   - Verify that the correct payment UI is displayed based on detected location\n   - Test the persistence of manual selection throughout a user session\n\n3. End-to-End Testing:\n   - Use a VPN to simulate access from different countries (Korea and non-Korea)\n   - Verify that the correct payment method is automatically selected based on location\n   - Test the manual toggle functionality to switch between payment methods\n   - Confirm that the appropriate currency and payment form is displayed\n\n4. Edge Case Testing:\n   - Test behavior when geolocation service is unavailable\n   - Verify handling of unknown or unsupported countries\n   - Test with various network conditions (slow, intermittent)\n\n5. UI/UX Testing:\n   - Verify that the manual selection option is clearly visible and intuitive\n   - Test the responsiveness of the payment selection UI on different devices\n   - Ensure appropriate loading states are displayed during IP detection\n\n6. Performance Testing:\n   - Measure the impact of IP detection on page load times\n   - Verify that caching mechanisms work correctly to avoid repeated lookups",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Port One SDK Integration and Payment Processing",
        "description": "Integrate Port One JavaScript SDK into the web application and implement the payment flow for Korean users, including SDK setup, payment UI implementation, and payment process handling.",
        "details": "This task involves integrating the Port One payment gateway for Korean users to purchase Star Candy:\n\n1. Port One SDK Installation and Configuration:\n   - Install the Port One JavaScript SDK via npm: `npm install portone`\n   - Add the SDK initialization code to the appropriate component or service:\n   ```javascript\n   import { loadPortOne } from '@portone/sdk';\n   \n   // Initialize with your merchant ID\n   const portOne = await loadPortOne('YOUR_MERCHANT_ID');\n   ```\n   - Configure the SDK with necessary environment settings (test/production mode)\n   - Set up error handling for SDK initialization failures\n\n2. Payment UI Implementation:\n   - Create a PaymentModal component that will be triggered when a user selects a product and clicks \"Purchase\"\n   - Implement form fields for collecting necessary payment information\n   - Design the payment UI to match the application's existing style guidelines\n   - Add loading states and error handling for a smooth user experience\n   - Ensure the payment UI is responsive and works well on both desktop and mobile devices\n\n3. Payment Process Implementation:\n   - Implement the payment request function that will be called when the user confirms payment:\n   ```javascript\n   const requestPayment = async (productInfo) => {\n     try {\n       const response = await portOne.requestPayment({\n         amount: productInfo.web_price_krw,\n         orderId: generateOrderId(), // Implement a unique order ID generator\n         orderName: `${productInfo.name} - ${productInfo.web_bonus_amount} Star Candy`,\n         successUrl: `${window.location.origin}/payment/success`,\n         failUrl: `${window.location.origin}/payment/fail`,\n         // Additional configuration as needed\n       });\n       \n       if (response.status === 'success') {\n         // Handle successful payment\n         await processSuccessfulPayment(response, productInfo);\n       } else {\n         // Handle payment failure\n         handlePaymentFailure(response);\n       }\n     } catch (error) {\n       // Handle exceptions\n       console.error('Payment processing error:', error);\n       notifyUser('Payment processing failed. Please try again.');\n     }\n   };\n   ```\n   \n4. Payment Callback Handling:\n   - Implement success and failure callback routes (/payment/success and /payment/fail)\n   - Create handlers to process the payment response from Port One\n   - Verify the payment status with the Port One API to prevent fraud\n   - Update the user's Star Candy balance in the database upon successful payment\n   - Provide appropriate feedback to the user based on payment result\n\n5. Testing Environment Setup:\n   - Configure the Port One SDK in test mode for development\n   - Set up test payment methods and virtual accounts for testing\n   - Create a toggle mechanism to switch between test and production environments",
        "testStrategy": "1. Unit Testing:\n   - Test the Port One SDK initialization with both valid and invalid merchant IDs\n   - Verify payment request function handles various product information correctly\n   - Test error handling for different payment scenarios (timeout, cancellation, etc.)\n   - Validate the order ID generation logic produces unique IDs\n\n2. Integration Testing:\n   - Test the complete payment flow using Port One's test environment\n   - Verify successful payments correctly update the user's Star Candy balance\n   - Test payment cancellation and failure scenarios\n   - Ensure callback URLs are correctly processed\n   - Verify the payment verification process correctly identifies valid and invalid payments\n\n3. UI Testing:\n   - Verify the payment modal renders correctly on different screen sizes\n   - Test form validation for payment information\n   - Ensure loading states and error messages display appropriately\n   - Verify the UI matches design specifications\n\n4. End-to-End Testing:\n   - Complete test purchases using Port One's test payment methods\n   - Verify the entire flow from product selection to Star Candy balance update\n   - Test the integration with the IP-based payment method selection logic\n   - Ensure users can successfully complete payments in different scenarios\n\n5. Security Testing:\n   - Verify that sensitive payment information is not logged or stored improperly\n   - Test that payment verification prevents fraudulent transactions\n   - Ensure proper error handling doesn't expose sensitive information",
        "status": "done",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement PayPal SDK Integration and Payment Processing",
        "description": "Integrate PayPal JavaScript SDK into the web application and implement the payment flow for international users, including SDK setup, payment button implementation, and payment process handling.",
        "details": "This task involves integrating the PayPal payment gateway for international users to purchase Star Candy:\n\n1. PayPal SDK Installation and Configuration:\n   - Install the PayPal JavaScript SDK via npm: `npm install @paypal/paypal-js`\n   - Add the SDK initialization code to the appropriate component or service:\n   ```javascript\n   import { loadScript } from \"@paypal/paypal-js\";\n   \n   // Initialize with your client ID\n   loadScript({ \n     \"client-id\": \"YOUR_PAYPAL_CLIENT_ID\",\n     currency: \"USD\" \n   })\n   .then((paypal) => {\n     // SDK loaded successfully\n   })\n   .catch((err) => {\n     console.error(\"Failed to load the PayPal JS SDK script\", err);\n   });\n   ```\n   - Store PayPal credentials securely in environment variables\n   - Create a PayPalService class to handle SDK initialization and payment operations\n\n2. PayPal Payment Button Implementation:\n   - Create a PayPalPaymentComponent that renders the PayPal button\n   - Implement the button with appropriate styling to match the application design:\n   ```javascript\n   paypal.Buttons({\n     style: {\n       layout: 'vertical',\n       color: 'blue',\n       shape: 'rect',\n       label: 'paypal'\n     },\n     createOrder: function(data, actions) {\n       // Create order based on selected product\n       return actions.order.create({\n         purchase_units: [{\n           amount: {\n             value: selectedProduct.web_price_usd,\n             currency_code: 'USD'\n           },\n           description: `${selectedProduct.amount} Star Candy`\n         }]\n       });\n     },\n     onApprove: function(data, actions) {\n       // Handle successful payment\n       return actions.order.capture().then(function(details) {\n         // Call backend to process the successful payment\n         return processPayPalPayment(data.orderID, details);\n       });\n     },\n     onCancel: function(data) {\n       // Handle payment cancellation\n       handlePaymentCancellation();\n     },\n     onError: function(err) {\n       // Handle payment errors\n       handlePaymentError(err);\n     }\n   }).render('#paypal-button-container');\n   ```\n\n3. Backend Payment Processing:\n   - Implement an API endpoint to verify and process PayPal payments\n   - Create a function to validate the payment with PayPal's server:\n   ```javascript\n   async function verifyPayPalPayment(orderId) {\n     // Call PayPal API to verify the payment\n     const response = await fetch(`https://api.paypal.com/v2/checkout/orders/${orderId}`, {\n       headers: {\n         'Authorization': `Bearer ${accessToken}`,\n         'Content-Type': 'application/json'\n       }\n     });\n     return response.json();\n   }\n   ```\n   - Update the user's Star Candy balance in the database upon successful payment\n   - Generate and store payment receipt information\n\n4. Payment Success/Failure Handling:\n   - Implement success page/modal showing payment confirmation and updated Star Candy balance\n   - Create error handling for failed payments with appropriate user feedback\n   - Add logging for payment events for troubleshooting and analytics\n\n5. Integration with IP-Based Selection Logic:\n   - Ensure the PayPal payment option appears for international users based on the IP detection logic\n   - Make sure the component works correctly when manually selected by Korean users\n\n6. Testing in Sandbox Environment:\n   - Set up PayPal sandbox accounts for testing\n   - Configure the application to use sandbox credentials in development/testing environments",
        "testStrategy": "1. Unit Testing:\n   - Test the PayPal SDK initialization with both valid and invalid client IDs\n   - Verify payment request function handles various product information correctly\n   - Test error handling for different payment scenarios (cancellation, timeout, etc.)\n   - Validate the order ID generation and verification logic\n\n2. Integration Testing:\n   - Test the integration between the PayPal button component and the backend payment processing\n   - Verify that the Star Candy balance updates correctly after successful payments\n   - Test the payment flow with different product selections\n   - Ensure proper integration with the IP-based payment method selection logic\n\n3. Sandbox Testing:\n   - Complete end-to-end payment flows using PayPal sandbox accounts\n   - Test various payment scenarios (successful payment, cancellation, declined payment)\n   - Verify webhook handling for payment notifications\n\n4. UI/UX Testing:\n   - Verify the PayPal button renders correctly on different browsers and devices\n   - Test the responsive behavior of the payment UI\n   - Ensure loading states and error messages are displayed appropriately\n   - Verify the success page/modal displays correct information\n\n5. Security Testing:\n   - Verify that PayPal credentials are properly secured and not exposed to clients\n   - Test CSRF protection on payment endpoints\n   - Ensure payment verification is properly implemented to prevent fraud\n\n6. Performance Testing:\n   - Measure and optimize the loading time of the PayPal SDK\n   - Test the performance of the payment processing under load\n\n7. Acceptance Testing:\n   - Verify that the entire payment flow meets the business requirements\n   - Confirm that the user experience matches the design specifications",
        "status": "done",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create Port One Payment Verification Edge Function",
        "description": "Implement an Edge Function to verify Port One payments, process webhooks, validate payment data, record transactions in the receipt table, and update user Star Candy and bonus balances.",
        "details": "This task involves creating a serverless Edge Function to handle Port One payment verification and post-payment processing:\n\n1. Create a new Edge Function in Supabase:\n   - Navigate to the Supabase dashboard and select the Edge Functions section\n   - Create a new function named `port-one-payment-verification`\n   - Set up appropriate CORS and security configurations\n\n2. Implement webhook handler for Port One callbacks:\n   ```typescript\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\n   const supabaseUrl = Deno.env.get('SUPABASE_URL')\n   const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')\n   const portOneSecretKey = Deno.env.get('PORT_ONE_SECRET_KEY')\n\n   serve(async (req) => {\n     // Initialize Supabase client\n     const supabase = createClient(supabaseUrl, supabaseServiceKey)\n     \n     // Parse webhook payload\n     const payload = await req.json()\n     \n     try {\n       // Verify the webhook signature\n       const signature = req.headers.get('x-portone-signature')\n       if (!verifySignature(payload, signature, portOneSecretKey)) {\n         return new Response(JSON.stringify({ error: 'Invalid signature' }), { \n           status: 401, \n           headers: { 'Content-Type': 'application/json' } \n         })\n       }\n       \n       // Process the payment verification\n       const result = await verifyPayment(payload, supabase)\n       return new Response(JSON.stringify(result), { \n         status: 200, \n         headers: { 'Content-Type': 'application/json' } \n       })\n     } catch (error) {\n       return new Response(JSON.stringify({ error: error.message }), { \n         status: 500, \n         headers: { 'Content-Type': 'application/json' } \n       })\n     }\n   })\n   ```\n\n3. Implement payment verification logic:\n   ```typescript\n   async function verifyPayment(payload, supabase) {\n     // Extract payment information\n     const { imp_uid, merchant_uid, status } = payload\n     \n     // Verify payment status\n     if (status !== 'paid') {\n       throw new Error(`Payment not completed. Status: ${status}`)\n     }\n     \n     // Fetch payment details from Port One API for verification\n     const portOneResponse = await fetch(`https://api.iamport.kr/payments/${imp_uid}`, {\n       headers: {\n         'Authorization': `Bearer ${await getPortOneToken()}`\n       }\n     })\n     \n     const portOneData = await portOneResponse.json()\n     \n     // Verify payment amount and details\n     const { amount, status: portOneStatus } = portOneData.response\n     \n     // Fetch order details from database\n     const { data: orderData, error: orderError } = await supabase\n       .from('orders')\n       .select('*')\n       .eq('order_id', merchant_uid)\n       .single()\n     \n     if (orderError) throw new Error(`Order not found: ${orderError.message}`)\n     \n     // Verify payment amount matches order amount\n     if (amount !== orderData.amount) {\n       throw new Error(`Payment amount mismatch: expected ${orderData.amount}, got ${amount}`)\n     }\n     \n     // Record the payment in receipts table\n     const { data: receiptData, error: receiptError } = await supabase\n       .from('receipts')\n       .insert({\n         user_id: orderData.user_id,\n         product_id: orderData.product_id,\n         payment_id: imp_uid,\n         order_id: merchant_uid,\n         amount: amount,\n         currency: orderData.currency,\n         payment_method: 'port_one',\n         status: 'completed',\n         payment_details: portOneData.response\n       })\n       .select()\n       .single()\n     \n     if (receiptError) throw new Error(`Failed to record receipt: ${receiptError.message}`)\n     \n     // Update user's Star Candy and bonus balance\n     const { data: productData, error: productError } = await supabase\n       .from('products')\n       .select('star_candy_amount, web_bonus_amount')\n       .eq('id', orderData.product_id)\n       .single()\n     \n     if (productError) throw new Error(`Product not found: ${productError.message}`)\n     \n     const { error: userUpdateError } = await supabase.rpc('update_user_star_candy', {\n       p_user_id: orderData.user_id,\n       p_star_candy_amount: productData.star_candy_amount,\n       p_bonus_amount: productData.web_bonus_amount\n     })\n     \n     if (userUpdateError) throw new Error(`Failed to update user balance: ${userUpdateError.message}`)\n     \n     return {\n       success: true,\n       receipt_id: receiptData.id,\n       message: 'Payment verified and processed successfully'\n     }\n   }\n   ```\n\n4. Implement Port One token retrieval function:\n   ```typescript\n   async function getPortOneToken() {\n     const response = await fetch('https://api.iamport.kr/users/getToken', {\n       method: 'POST',\n       headers: {\n         'Content-Type': 'application/json'\n       },\n       body: JSON.stringify({\n         imp_key: Deno.env.get('PORT_ONE_API_KEY'),\n         imp_secret: Deno.env.get('PORT_ONE_API_SECRET')\n       })\n     })\n     \n     const data = await response.json()\n     return data.response.access_token\n   }\n   ```\n\n5. Implement signature verification function:\n   ```typescript\n   function verifySignature(payload, signature, secretKey) {\n     // Implement cryptographic verification based on Port One documentation\n     // This typically involves creating a hash of the payload with the secret key\n     // and comparing it to the provided signature\n     const crypto = require('crypto')\n     const calculatedSignature = crypto\n       .createHmac('sha256', secretKey)\n       .update(JSON.stringify(payload))\n       .digest('hex')\n     \n     return calculatedSignature === signature\n   }\n   ```\n\n6. Create a stored procedure in Supabase for updating user Star Candy:\n   ```sql\n   CREATE OR REPLACE FUNCTION update_user_star_candy(\n     p_user_id UUID,\n     p_star_candy_amount INTEGER,\n     p_bonus_amount INTEGER\n   ) RETURNS VOID AS $$\n   BEGIN\n     UPDATE users\n     SET \n       star_candy = star_candy + p_star_candy_amount,\n       bonus_star_candy = bonus_star_candy + p_bonus_amount,\n       updated_at = NOW()\n     WHERE id = p_user_id;\n   END;\n   $$ LANGUAGE plpgsql SECURITY DEFINER;\n   ```\n\n7. Deploy the Edge Function:\n   - Test the function locally using Supabase CLI\n   - Deploy to the Supabase project\n   - Configure environment variables in the Supabase dashboard\n\n8. Configure Port One webhook settings:\n   - Log in to the Port One merchant dashboard\n   - Set up the webhook URL to point to your deployed Edge Function\n   - Configure the webhook to trigger on payment completion events",
        "testStrategy": "1. Unit Testing:\n   - Create mock Port One webhook payloads for various scenarios (successful payment, failed payment, etc.)\n   - Test the signature verification function with valid and invalid signatures\n   - Test the payment verification logic with different payment statuses and amounts\n   - Verify error handling for various edge cases (missing data, API failures, etc.)\n\n2. Integration Testing:\n   - Deploy the Edge Function to a development environment\n   - Use Port One's test mode to simulate payment completions\n   - Verify the Edge Function correctly processes the webhook and updates the database\n   - Test with different product types and payment amounts\n   - Verify the function handles concurrent webhook calls properly\n\n3. Database Verification:\n   - After a test payment, query the receipts table to verify the payment was recorded correctly\n   - Check that all required fields in the receipt record are populated correctly\n   - Verify the user's Star Candy and bonus balances are updated correctly\n   - Ensure no duplicate entries are created for the same payment\n\n4. Error Handling Verification:\n   - Test with invalid webhook signatures to ensure unauthorized requests are rejected\n   - Simulate database connection failures to verify proper error handling\n   - Test with malformed webhook payloads to ensure robust error handling\n   - Verify appropriate error responses are returned for all error scenarios\n\n5. Performance Testing:\n   - Measure the response time of the Edge Function under normal load\n   - Test with concurrent webhook calls to ensure proper handling\n   - Verify the function completes within acceptable time limits\n\n6. Security Testing:\n   - Verify that the Edge Function properly validates all input data\n   - Ensure sensitive payment information is handled securely\n   - Check that appropriate authentication is required for accessing the function\n   - Verify that error messages don't expose sensitive information\n\n7. End-to-End Testing:\n   - Complete a full payment flow from the web application\n   - Verify the webhook is received and processed correctly\n   - Check that the user's Star Candy balance is updated in the UI\n   - Verify the receipt is accessible in the user's purchase history",
        "status": "done",
        "dependencies": [
          1,
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create PayPal Payment Verification Edge Function",
        "description": "Implement an Edge Function to verify PayPal payments, process webhooks, validate payment data, record transactions in the receipt table, and update user Star Candy and bonus balances.",
        "details": "This task involves creating a serverless Edge Function to handle PayPal payment verification and post-payment processing:\n\n1. Create a new Edge Function in Supabase:\n   - Navigate to the Supabase dashboard and select the Edge Functions section\n   - Create a new function named `paypal-payment-verification`\n   - Set up appropriate CORS and security configurations\n\n2. Implement webhook handler for PayPal callbacks:\n   ```typescript\n   import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\n   import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\n   \n   const supabase = createClient(\n     Deno.env.get('SUPABASE_URL') ?? '',\n     Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n   );\n   \n   serve(async (req) => {\n     // Handle CORS preflight requests\n     if (req.method === 'OPTIONS') {\n       return new Response(null, {\n         headers: {\n           'Access-Control-Allow-Origin': '*',\n           'Access-Control-Allow-Methods': 'POST, OPTIONS',\n           'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n         },\n       });\n     }\n     \n     // Only allow POST requests\n     if (req.method !== 'POST') {\n       return new Response(JSON.stringify({ error: 'Method not allowed' }), {\n         status: 405,\n         headers: { 'Content-Type': 'application/json' },\n       });\n     }\n     \n     try {\n       const payload = await req.json();\n       // Process PayPal webhook payload\n       // ...\n     } catch (error) {\n       // Handle errors\n       // ...\n     }\n   });\n   ```\n\n3. Implement PayPal payment verification logic:\n   - Verify the webhook signature using PayPal's verification process\n   - Extract payment details from the webhook payload\n   - Validate the payment amount, currency, and status\n   - Check for duplicate transactions to prevent double processing\n   \n   ```typescript\n   // Verify PayPal webhook signature\n   async function verifyPayPalWebhook(payload, headers) {\n     const webhookId = Deno.env.get('PAYPAL_WEBHOOK_ID');\n     // Implement PayPal's webhook verification logic\n     // This typically involves making a request to PayPal's API to verify the signature\n     // Return true if verified, false otherwise\n   }\n   \n   // Verify payment details\n   async function verifyPayment(paymentData) {\n     // Extract order ID, payment amount, currency, etc.\n     const { orderId, amount, currency, status } = paymentData;\n     \n     // Verify payment status is 'COMPLETED'\n     if (status !== 'COMPLETED') {\n       return { verified: false, reason: 'Payment not completed' };\n     }\n     \n     // Verify payment amount and currency match expected values\n     // This would involve looking up the original order in your database\n     const { data: order, error } = await supabase\n       .from('orders')\n       .select('*')\n       .eq('order_id', orderId)\n       .single();\n       \n     if (error || !order) {\n       return { verified: false, reason: 'Order not found' };\n     }\n     \n     if (order.amount !== amount || order.currency !== currency) {\n       return { verified: false, reason: 'Payment amount or currency mismatch' };\n     }\n     \n     return { verified: true, order };\n   }\n   ```\n\n4. Implement receipt recording and balance update logic:\n   - Record the verified payment in the receipts table\n   - Update the user's Star Candy balance\n   - Add bonus Star Candy if applicable\n   \n   ```typescript\n   async function recordTransaction(paymentData, order) {\n     const { data: user, error: userError } = await supabase\n       .from('users')\n       .select('id, star_candy_balance')\n       .eq('id', order.user_id)\n       .single();\n       \n     if (userError || !user) {\n       throw new Error('User not found');\n     }\n     \n     // Start a transaction to ensure data consistency\n     const { error: transactionError } = await supabase.rpc('process_payment_transaction', {\n       p_user_id: user.id,\n       p_order_id: order.order_id,\n       p_payment_id: paymentData.id,\n       p_amount: order.amount,\n       p_currency: order.currency,\n       p_product_id: order.product_id,\n       p_star_candy_amount: order.star_candy_amount,\n       p_bonus_amount: order.bonus_amount,\n       p_payment_method: 'paypal',\n       p_payment_status: paymentData.status,\n       p_payment_data: JSON.stringify(paymentData)\n     });\n     \n     if (transactionError) {\n       throw new Error(`Transaction error: ${transactionError.message}`);\n     }\n     \n     return { success: true };\n   }\n   ```\n\n5. Create a database function to handle the transaction:\n   - Implement a PostgreSQL function in Supabase that handles the entire transaction\n   - This ensures atomicity of the receipt creation and balance update\n   \n   ```sql\n   CREATE OR REPLACE FUNCTION process_payment_transaction(\n     p_user_id UUID,\n     p_order_id TEXT,\n     p_payment_id TEXT,\n     p_amount NUMERIC,\n     p_currency TEXT,\n     p_product_id UUID,\n     p_star_candy_amount INTEGER,\n     p_bonus_amount INTEGER,\n     p_payment_method TEXT,\n     p_payment_status TEXT,\n     p_payment_data JSONB\n   ) RETURNS VOID AS $$\n   DECLARE\n     v_total_amount INTEGER;\n   BEGIN\n     -- Calculate total amount (star candy + bonus)\n     v_total_amount := p_star_candy_amount + p_bonus_amount;\n     \n     -- Insert receipt record\n     INSERT INTO receipts (\n       user_id, \n       order_id, \n       payment_id, \n       amount, \n       currency, \n       product_id, \n       star_candy_amount, \n       bonus_amount, \n       payment_method, \n       payment_status, \n       payment_data\n     ) VALUES (\n       p_user_id,\n       p_order_id,\n       p_payment_id,\n       p_amount,\n       p_currency,\n       p_product_id,\n       p_star_candy_amount,\n       p_bonus_amount,\n       p_payment_method,\n       p_payment_status,\n       p_payment_data\n     );\n     \n     -- Update user's star candy balance\n     UPDATE users\n     SET \n       star_candy_balance = star_candy_balance + v_total_amount,\n       updated_at = NOW()\n     WHERE id = p_user_id;\n   END;\n   $$ LANGUAGE plpgsql;\n   ```\n\n6. Implement error handling and logging:\n   - Add comprehensive error handling for all possible failure scenarios\n   - Implement logging to track payment processing issues\n   - Set up alerts for critical payment verification failures\n   \n   ```typescript\n   // Error handling and logging\n   async function logError(error, context) {\n     console.error('Payment verification error:', error);\n     \n     // Log error to database for tracking\n     await supabase\n       .from('error_logs')\n       .insert({\n         error_message: error.message,\n         error_stack: error.stack,\n         context: JSON.stringify(context),\n         source: 'paypal-payment-verification'\n       });\n       \n     // Could also integrate with external monitoring services here\n   }\n   ```\n\n7. Deploy and test the Edge Function:\n   - Deploy the function to the Supabase environment\n   - Configure PayPal webhook settings to point to the deployed function URL\n   - Test with PayPal's sandbox environment before going live",
        "testStrategy": "1. Unit Testing:\n   - Create mock PayPal webhook payloads for various scenarios (successful payment, failed payment, etc.)\n   - Test the signature verification function with valid and invalid signatures\n   - Test the payment verification logic with different payment statuses and amounts\n   - Verify the transaction recording function correctly updates the database\n\n2. Integration Testing:\n   - Set up a test environment with PayPal sandbox credentials\n   - Configure PayPal sandbox webhooks to point to your test Edge Function\n   - Complete test purchases through the PayPal sandbox\n   - Verify webhooks are received and processed correctly\n   - Check that receipts are created with correct information\n   - Confirm user Star Candy balances are updated appropriately\n\n3. Error Handling Testing:\n   - Test with malformed webhook payloads\n   - Simulate network failures during verification\n   - Test with invalid payment data\n   - Verify error logging works correctly\n   - Ensure duplicate webhook handling works properly\n\n4. Security Testing:\n   - Verify webhook signature validation prevents tampering\n   - Test CORS configuration to ensure proper access control\n   - Check that sensitive payment data is properly handled\n   - Verify that only authorized PayPal events trigger updates\n\n5. Performance Testing:\n   - Measure response times for webhook processing\n   - Test with high volume of concurrent webhook events\n   - Verify database transaction performance under load\n\n6. End-to-End Testing:\n   - Complete a full payment flow from the web application\n   - Verify the entire process from payment initiation to balance update\n   - Check that users receive the correct amount of Star Candy and bonus\n   - Verify the receipt is visible in the user's transaction history\n\n7. Production Verification:\n   - Monitor initial production transactions closely\n   - Verify logs for any unexpected errors\n   - Check database records for accuracy\n   - Confirm user balances are updated correctly in production",
        "status": "done",
        "dependencies": [
          1,
          5
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-26T03:12:59.547Z",
      "updated": "2025-06-26T05:31:58.674Z",
      "description": "Payment feature development"
    }
  }
}