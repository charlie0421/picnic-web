d3b6ab3d31f8e406b1e7e718730f79be
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _HybridVoteDetailPresenter = require("../../../components/client/vote/detail/HybridVoteDetailPresenter");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock Supabase client with explicit typing
const createMockSupabaseClient = ()=>({
        auth: {
            getUser: _globals.jest.fn()
        },
        from: _globals.jest.fn(),
        channel: _globals.jest.fn()
    });
const mockSupabaseClient = createMockSupabaseClient();
// Mock hooks
_globals.jest.mock('@/lib/supabase/client', ()=>({
        createBrowserSupabaseClient: ()=>mockSupabaseClient
    }));
_globals.jest.mock('@/stores/languageStore', ()=>({
        useLanguageStore: ()=>({
                currentLanguage: 'ko'
            })
    }));
// Mock useAuthGuard hook completely
_globals.jest.mock('@/hooks/useAuthGuard', ()=>({
        useAuthGuard: _globals.jest.fn(()=>({
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                },
                session: {
                    access_token: 'mock-token'
                },
                isLoading: false,
                signOut: _globals.jest.fn(),
                requireAuth: _globals.jest.fn()
            })),
        useRequireAuth: _globals.jest.fn(()=>({
                withAuth: _globals.jest.fn((fn)=>(...args)=>fn(...args))
            }))
    }));
// Mock AuthProvider completely
_globals.jest.mock('@/lib/supabase/auth-provider', ()=>({
        AuthProvider: ({ children })=>children,
        useAuth: _globals.jest.fn(()=>({
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                },
                session: {
                    access_token: 'mock-token'
                },
                isLoading: false,
                signOut: _globals.jest.fn()
            }))
    }));
// Mock data with correct types
const mockVote = {
    id: 1,
    title: {
        ko: 'Test Vote'
    },
    vote_content: 'Test vote description',
    start_at: new Date('2024-01-01T00:00:00Z').toISOString(),
    stop_at: new Date('2024-12-31T23:59:59Z').toISOString(),
    area: 'global',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    deleted_at: null,
    main_image: null,
    order: null,
    result_image: null,
    visible_at: null,
    vote_category: null,
    vote_sub_category: null,
    wait_image: null
};
const mockVoteItems = [
    {
        id: 1,
        artist_id: 1,
        group_id: 1,
        vote_id: 1,
        vote_total: 100,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        deleted_at: null,
        artist: {
            id: 1,
            name: {
                ko: 'Artist 1'
            },
            image: 'https://example.com/artist1.jpg',
            birth_date: null,
            created_at: new Date().toISOString(),
            debut_date: null,
            debut_dd: null,
            debut_mm: null,
            debut_yy: null,
            deleted_at: null,
            gender: null,
            group_id: null,
            is_kpop: true,
            is_musical: false,
            is_solo: true,
            updated_at: new Date().toISOString(),
            dd: null,
            mm: null,
            yy: null
        }
    },
    {
        id: 2,
        artist_id: 2,
        group_id: 1,
        vote_id: 1,
        vote_total: 50,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        deleted_at: null,
        artist: {
            id: 2,
            name: {
                ko: 'Artist 2'
            },
            image: 'https://example.com/artist2.jpg',
            birth_date: null,
            created_at: new Date().toISOString(),
            debut_date: null,
            debut_dd: null,
            debut_mm: null,
            debut_yy: null,
            deleted_at: null,
            gender: null,
            group_id: null,
            is_kpop: true,
            is_musical: false,
            is_solo: true,
            updated_at: new Date().toISOString(),
            dd: null,
            mm: null,
            yy: null
        }
    }
];
// Helper function to create mock chain
const createMockChain = (resolveValue, rejectValue)=>{
    const mockSingle = _globals.jest.fn();
    if (rejectValue) {
        mockSingle.mockRejectedValue(rejectValue);
    } else {
        mockSingle.mockResolvedValue(resolveValue || {
            data: {
                id: 1,
                title: {
                    ko: 'Test Vote'
                },
                vote_content: 'Test vote description',
                vote_item: [
                    {
                        id: 1,
                        vote_total: 100,
                        artist: {
                            id: 1,
                            name: {
                                ko: 'Artist 1'
                            },
                            image: 'artist1.jpg'
                        }
                    },
                    {
                        id: 2,
                        vote_total: 50,
                        artist: {
                            id: 2,
                            name: {
                                ko: 'Artist 2'
                            },
                            image: 'artist2.jpg'
                        }
                    }
                ]
            }
        });
    }
    const mockEq = _globals.jest.fn().mockReturnValue({
        single: mockSingle
    });
    const mockSelect = _globals.jest.fn().mockReturnValue({
        eq: mockEq
    });
    return {
        mockSelect,
        mockEq,
        mockSingle
    };
};
// Test Wrapper with complete mocked context
const TestWrapper = ({ children })=>{
    const mockAuthContext = _react.default.useMemo(()=>({
            user: {
                id: 'user123',
                email: 'test@example.com'
            },
            session: {
                access_token: 'mock-token'
            },
            isLoading: false,
            signOut: _globals.jest.fn()
        }), []);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        "data-testid": "auth-provider",
        children: children
    });
};
describe('HybridVoteDetailPresenter', ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        _globals.jest.useFakeTimers();
        // Setup default mocks with proper typing
        mockSupabaseClient.auth.getUser.mockResolvedValue({
            data: {
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                }
            }
        });
        const { mockSelect } = createMockChain();
        mockSupabaseClient.from.mockReturnValue({
            select: mockSelect
        });
    });
    afterEach(()=>{
        _globals.jest.useRealTimers();
    });
    describe('기본 렌더링 테스트', ()=>{
        it('컴포넌트가 정상적으로 렌더링되어야 함', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems
            }));
            // 투표 제목 확인 (JSON 객체에서 한국어 제목 추출)
            expect(_react1.screen.getByText('Test Vote')).toBeInTheDocument();
        });
        it('초기 투표 아이템들이 표시되어야 함', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems
            }));
            // Artist 이름이 JSON 객체로 저장되므로 적절한 텍스트를 찾아야 함
            expect(_react1.screen.getByText(/Artist 1|아티스트/)).toBeInTheDocument();
        });
    });
    describe('폴링 모드 테스트', ()=>{
        it('폴링 모드에서 지정된 간격으로 데이터를 가져와야 함', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false,
                pollingInterval: 1000
            }));
            // 초기 호출
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from).toHaveBeenCalled();
            });
            const initialCallCount = mockSupabaseClient.from.mock.calls.length;
            // 1초 후 추가 호출 확인
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from.mock.calls.length).toBeGreaterThan(initialCallCount);
            });
        });
        it('폴링 에러 발생 시 에러 알림이 표시되어야 함', async ()=>{
            const { mockSelect } = createMockChain(undefined, new Error('Network error'));
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 에러 알림이 표시되는지 확인
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/데이터 로딩 오류|오류|error/i)).toBeInTheDocument();
            });
        });
        it('폴링 성공 시 투표 데이터가 업데이트되어야 함', async ()=>{
            const updatedData = {
                data: {
                    id: 1,
                    title: {
                        ko: 'Updated Vote'
                    },
                    vote_content: 'Updated description',
                    vote_item: [
                        {
                            id: 1,
                            vote_total: 150,
                            artist: {
                                id: 1,
                                name: {
                                    ko: 'Artist 1'
                                },
                                image: 'artist1.jpg'
                            }
                        }
                    ]
                }
            };
            const { mockSelect } = createMockChain(updatedData);
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 업데이트된 데이터가 표시되는지 확인 (150이라는 숫자가 화면에 있는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('150')).toBeInTheDocument();
            });
        });
    });
    describe('정적 모드 테스트', ()=>{
        it('정적 모드에서는 자동 업데이트가 발생하지 않아야 함', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false,
                pollingInterval: 0
            }));
            const initialCallCount = mockSupabaseClient.from.mock.calls.length;
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(5000); // 5초 대기
            });
            // API 호출이 추가로 발생하지 않았는지 확인
            expect(mockSupabaseClient.from.mock.calls.length).toBe(initialCallCount);
        });
    });
    describe('실시간 모드 테스트', ()=>{
        it('실시간 모드가 활성화될 때 Supabase 채널을 구독해야 함', async ()=>{
            const mockSubscribe = _globals.jest.fn();
            const mockOn = _globals.jest.fn().mockReturnValue({
                subscribe: mockSubscribe
            });
            mockSupabaseClient.channel.mockReturnValue({
                on: mockOn
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: true
            }));
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.channel).toHaveBeenCalledWith('supabase_realtime');
            });
        });
        it('실시간 연결 실패 시 폴링 모드로 자동 전환되어야 함', async ()=>{
            const mockSubscribe = _globals.jest.fn();
            mockSubscribe.mockImplementation((callback)=>{
                // 연결 실패 시뮬레이션
                setTimeout(()=>callback('CHANNEL_ERROR', new Error('Connection failed')), 100);
                return {
                    unsubscribe: _globals.jest.fn()
                };
            });
            const mockOn = _globals.jest.fn().mockReturnValue({
                subscribe: mockSubscribe
            });
            mockSupabaseClient.channel.mockReturnValue({
                on: mockOn
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: true
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(200);
            });
            // 폴링 모드로 전환 확인 (API 호출이 시작되었는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from).toHaveBeenCalled();
            });
        });
    });
    describe('연결 품질 모니터링 테스트', ()=>{
        it('연속 에러 발생 시 에러가 누적되어야 함', async ()=>{
            // 에러를 반환하는 모킹 설정
            const { mockSelect } = createMockChain(undefined, new Error('Network error'));
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 여러 번의 폴링으로 연속 에러 발생
            for(let i = 0; i < 3; i++){
                await (0, _react1.act)(async ()=>{
                    _globals.jest.advanceTimersByTime(1000);
                });
            }
            // 에러 메시지가 표시되는지 확인
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/오류|error/i)).toBeInTheDocument();
            });
        });
    });
    describe('성능 테스트', ()=>{
        it('빈번한 데이터 업데이트 시 메모리 누수가 발생하지 않아야 함', async ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 여러 번의 빠른 업데이트 시뮬레이션
            for(let i = 0; i < 10; i++){
                await (0, _react1.act)(async ()=>{
                    _globals.jest.advanceTimersByTime(100);
                });
            }
            // 컴포넌트 언마운트
            unmount();
            // 타이머가 정리되었는지 확인
            expect(_globals.jest.getTimerCount()).toBe(0);
        });
    });
    describe('에러 복구 테스트', ()=>{
        it('네트워크 복구 후 정상 동작으로 돌아와야 함', async ()=>{
            let shouldError = true;
            const mockSingle = _globals.jest.fn();
            mockSingle.mockImplementation(()=>{
                if (shouldError) {
                    return Promise.reject(new Error('Network error'));
                }
                return Promise.resolve({
                    data: {
                        id: 1,
                        vote_item: [
                            {
                                id: 1,
                                vote_total: 100,
                                artist: {
                                    id: 1,
                                    name: {
                                        ko: 'Artist 1'
                                    },
                                    image: 'artist1.jpg'
                                }
                            }
                        ]
                    }
                });
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 초기 에러 상태
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/오류|error/i)).toBeInTheDocument();
            });
            // 네트워크 복구 시뮬레이션
            shouldError = false;
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 정상 동작 복구 확인 (에러 메시지가 사라졌는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/데이터 로딩 오류/)).not.toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFybGllLmh5dW4vUmVwb3NpdG9yaWVzL3BpY25pYy13ZWIvX190ZXN0c19fL2NvbXBvbmVudHMvdm90ZS9IeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciwgZmlyZUV2ZW50LCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXIgfSBmcm9tICdAL2NvbXBvbmVudHMvY2xpZW50L3ZvdGUvZGV0YWlsL0h5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXInO1xuaW1wb3J0IHsgVm90ZSwgVm90ZUl0ZW0gfSBmcm9tICdAL3R5cGVzL2ludGVyZmFjZXMnO1xuXG4vLyBDcmVhdGUgcHJvcGVyIG1vY2sgdHlwZXNcbmludGVyZmFjZSBNb2NrU3VwYWJhc2VSZXNwb25zZSB7XG4gIGRhdGE6IGFueTtcbiAgZXJyb3I/OiBhbnk7XG59XG5cbmludGVyZmFjZSBNb2NrU3VwYWJhc2VDbGllbnQge1xuICBhdXRoOiB7XG4gICAgZ2V0VXNlcjogamVzdC5Nb2NrZWRGdW5jdGlvbjwoKSA9PiBQcm9taXNlPGFueT4+O1xuICB9O1xuICBmcm9tOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPCh0YWJsZTogc3RyaW5nKSA9PiBhbnk+O1xuICBjaGFubmVsOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPChuYW1lOiBzdHJpbmcpID0+IGFueT47XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgY2xpZW50IHdpdGggZXhwbGljaXQgdHlwaW5nXG5jb25zdCBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQgPSAoKTogTW9ja1N1cGFiYXNlQ2xpZW50ID0+ICh7XG4gIGF1dGg6IHtcbiAgICBnZXRVc2VyOiBqZXN0LmZuPCgpID0+IFByb21pc2U8YW55Pj4oKSxcbiAgfSxcbiAgZnJvbTogamVzdC5mbjwodGFibGU6IHN0cmluZykgPT4gYW55PigpLFxuICBjaGFubmVsOiBqZXN0LmZuPChuYW1lOiBzdHJpbmcpID0+IGFueT4oKSxcbn0pO1xuXG5jb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcblxuLy8gTW9jayBob29rc1xuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZS9jbGllbnQnLCAoKSA9PiAoe1xuICBjcmVhdGVCcm93c2VyU3VwYWJhc2VDbGllbnQ6ICgpID0+IG1vY2tTdXBhYmFzZUNsaWVudCxcbn0pKTtcblxuamVzdC5tb2NrKCdAL3N0b3Jlcy9sYW5ndWFnZVN0b3JlJywgKCkgPT4gKHtcbiAgdXNlTGFuZ3VhZ2VTdG9yZTogKCkgPT4gKHtcbiAgICBjdXJyZW50TGFuZ3VhZ2U6ICdrbycsXG4gIH0pLFxufSkpO1xuXG4vLyBNb2NrIHVzZUF1dGhHdWFyZCBob29rIGNvbXBsZXRlbHlcbmplc3QubW9jaygnQC9ob29rcy91c2VBdXRoR3VhcmQnLCAoKSA9PiAoe1xuICB1c2VBdXRoR3VhcmQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICB1c2VyOiB7IGlkOiAndXNlcjEyMycsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSxcbiAgICBzZXNzaW9uOiB7IGFjY2Vzc190b2tlbjogJ21vY2stdG9rZW4nIH0sXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBzaWduT3V0OiBqZXN0LmZuKCksXG4gICAgcmVxdWlyZUF1dGg6IGplc3QuZm4oKSxcbiAgfSkpLFxuICB1c2VSZXF1aXJlQXV0aDogamVzdC5mbigoKSA9PiAoe1xuICAgIHdpdGhBdXRoOiBqZXN0LmZuKChmbikgPT4gKC4uLmFyZ3M6IGFueVtdKSA9PiBmbiguLi5hcmdzKSksXG4gIH0pKSxcbn0pKTtcblxuLy8gTW9jayBBdXRoUHJvdmlkZXIgY29tcGxldGVseVxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZS9hdXRoLXByb3ZpZGVyJywgKCkgPT4gKHtcbiAgQXV0aFByb3ZpZGVyOiAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkgPT4gY2hpbGRyZW4sXG4gIHVzZUF1dGg6IGplc3QuZm4oKCkgPT4gKHtcbiAgICB1c2VyOiB7IGlkOiAndXNlcjEyMycsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSxcbiAgICBzZXNzaW9uOiB7IGFjY2Vzc190b2tlbjogJ21vY2stdG9rZW4nIH0sXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBzaWduT3V0OiBqZXN0LmZuKCksXG4gIH0pKSxcbn0pKTtcblxuLy8gTW9jayBkYXRhIHdpdGggY29ycmVjdCB0eXBlc1xuY29uc3QgbW9ja1ZvdGU6IFZvdGUgPSB7XG4gIGlkOiAxLFxuICB0aXRsZTogeyBrbzogJ1Rlc3QgVm90ZScgfSxcbiAgdm90ZV9jb250ZW50OiAnVGVzdCB2b3RlIGRlc2NyaXB0aW9uJyxcbiAgc3RhcnRfYXQ6IG5ldyBEYXRlKCcyMDI0LTAxLTAxVDAwOjAwOjAwWicpLnRvSVNPU3RyaW5nKCksXG4gIHN0b3BfYXQ6IG5ldyBEYXRlKCcyMDI0LTEyLTMxVDIzOjU5OjU5WicpLnRvSVNPU3RyaW5nKCksXG4gIGFyZWE6ICdnbG9iYWwnLFxuICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgZGVsZXRlZF9hdDogbnVsbCxcbiAgbWFpbl9pbWFnZTogbnVsbCxcbiAgb3JkZXI6IG51bGwsXG4gIHJlc3VsdF9pbWFnZTogbnVsbCxcbiAgdmlzaWJsZV9hdDogbnVsbCxcbiAgdm90ZV9jYXRlZ29yeTogbnVsbCxcbiAgdm90ZV9zdWJfY2F0ZWdvcnk6IG51bGwsXG4gIHdhaXRfaW1hZ2U6IG51bGwsXG59O1xuXG5jb25zdCBtb2NrVm90ZUl0ZW1zOiBWb3RlSXRlbVtdID0gW1xuICB7XG4gICAgaWQ6IDEsXG4gICAgYXJ0aXN0X2lkOiAxLFxuICAgIGdyb3VwX2lkOiAxLFxuICAgIHZvdGVfaWQ6IDEsXG4gICAgdm90ZV90b3RhbDogMTAwLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZGVsZXRlZF9hdDogbnVsbCxcbiAgICBhcnRpc3Q6IHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogeyBrbzogJ0FydGlzdCAxJyB9LFxuICAgICAgaW1hZ2U6ICdodHRwczovL2V4YW1wbGUuY29tL2FydGlzdDEuanBnJyxcbiAgICAgIGJpcnRoX2RhdGU6IG51bGwsXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkZWJ1dF9kYXRlOiBudWxsLFxuICAgICAgZGVidXRfZGQ6IG51bGwsXG4gICAgICBkZWJ1dF9tbTogbnVsbCxcbiAgICAgIGRlYnV0X3l5OiBudWxsLFxuICAgICAgZGVsZXRlZF9hdDogbnVsbCxcbiAgICAgIGdlbmRlcjogbnVsbCxcbiAgICAgIGdyb3VwX2lkOiBudWxsLFxuICAgICAgaXNfa3BvcDogdHJ1ZSxcbiAgICAgIGlzX211c2ljYWw6IGZhbHNlLFxuICAgICAgaXNfc29sbzogdHJ1ZSxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRkOiBudWxsLFxuICAgICAgbW06IG51bGwsXG4gICAgICB5eTogbnVsbCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgaWQ6IDIsXG4gICAgYXJ0aXN0X2lkOiAyLFxuICAgIGdyb3VwX2lkOiAxLFxuICAgIHZvdGVfaWQ6IDEsXG4gICAgdm90ZV90b3RhbDogNTAsXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkZWxldGVkX2F0OiBudWxsLFxuICAgIGFydGlzdDoge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiB7IGtvOiAnQXJ0aXN0IDInIH0sXG4gICAgICBpbWFnZTogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXJ0aXN0Mi5qcGcnLFxuICAgICAgYmlydGhfZGF0ZTogbnVsbCxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRlYnV0X2RhdGU6IG51bGwsXG4gICAgICBkZWJ1dF9kZDogbnVsbCxcbiAgICAgIGRlYnV0X21tOiBudWxsLFxuICAgICAgZGVidXRfeXk6IG51bGwsXG4gICAgICBkZWxldGVkX2F0OiBudWxsLFxuICAgICAgZ2VuZGVyOiBudWxsLFxuICAgICAgZ3JvdXBfaWQ6IG51bGwsXG4gICAgICBpc19rcG9wOiB0cnVlLFxuICAgICAgaXNfbXVzaWNhbDogZmFsc2UsXG4gICAgICBpc19zb2xvOiB0cnVlLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGQ6IG51bGwsXG4gICAgICBtbTogbnVsbCxcbiAgICAgIHl5OiBudWxsLFxuICAgIH0sXG4gIH0sXG5dO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgY2hhaW5cbmNvbnN0IGNyZWF0ZU1vY2tDaGFpbiA9IChyZXNvbHZlVmFsdWU/OiBhbnksIHJlamVjdFZhbHVlPzogYW55KSA9PiB7XG4gIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuPCgpID0+IFByb21pc2U8TW9ja1N1cGFiYXNlUmVzcG9uc2U+PigpO1xuICBcbiAgaWYgKHJlamVjdFZhbHVlKSB7XG4gICAgbW9ja1NpbmdsZS5tb2NrUmVqZWN0ZWRWYWx1ZShyZWplY3RWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbW9ja1NpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZShyZXNvbHZlVmFsdWUgfHwge1xuICAgICAgZGF0YToge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdGl0bGU6IHsga286ICdUZXN0IFZvdGUnIH0sXG4gICAgICAgIHZvdGVfY29udGVudDogJ1Rlc3Qgdm90ZSBkZXNjcmlwdGlvbicsXG4gICAgICAgIHZvdGVfaXRlbTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgdm90ZV90b3RhbDogMTAwLFxuICAgICAgICAgICAgYXJ0aXN0OiB7IGlkOiAxLCBuYW1lOiB7IGtvOiAnQXJ0aXN0IDEnIH0sIGltYWdlOiAnYXJ0aXN0MS5qcGcnIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogMixcbiAgICAgICAgICAgIHZvdGVfdG90YWw6IDUwLFxuICAgICAgICAgICAgYXJ0aXN0OiB7IGlkOiAyLCBuYW1lOiB7IGtvOiAnQXJ0aXN0IDInIH0sIGltYWdlOiAnYXJ0aXN0Mi5qcGcnIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gIHJldHVybiB7IG1vY2tTZWxlY3QsIG1vY2tFcSwgbW9ja1NpbmdsZSB9O1xufTtcblxuLy8gVGVzdCBXcmFwcGVyIHdpdGggY29tcGxldGUgbW9ja2VkIGNvbnRleHRcbmNvbnN0IFRlc3RXcmFwcGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IG1vY2tBdXRoQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICB1c2VyOiB7IGlkOiAndXNlcjEyMycsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSxcbiAgICBzZXNzaW9uOiB7IGFjY2Vzc190b2tlbjogJ21vY2stdG9rZW4nIH0sXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBzaWduT3V0OiBqZXN0LmZuKCksXG4gIH0pLCBbXSk7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJhdXRoLXByb3ZpZGVyXCI+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5kZXNjcmliZSgnSHlicmlkVm90ZURldGFpbFByZXNlbnRlcicsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gICAgXG4gICAgLy8gU2V0dXAgZGVmYXVsdCBtb2NrcyB3aXRoIHByb3BlciB0eXBpbmdcbiAgICBtb2NrU3VwYWJhc2VDbGllbnQuYXV0aC5nZXRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIGRhdGE6IHsgdXNlcjogeyBpZDogJ3VzZXIxMjMnLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0gfSxcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCB7IG1vY2tTZWxlY3QgfSA9IGNyZWF0ZU1vY2tDaGFpbigpO1xuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+q4sOuzuCDroIzrjZTrp4Eg7YWM7Iqk7Yq4JywgKCkgPT4ge1xuICAgIGl0KCfsu7Ttj6zrhIztirjqsIAg7KCV7IOB7KCB7Jy866GcIOugjOuNlOungeuQmOyWtOyVvCDtlagnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8g7Yis7ZGcIOygnOuqqSDtmZXsnbggKEpTT04g6rCd7LK07JeQ7IScIO2VnOq1reyWtCDsoJzrqqkg7LaU7LacKVxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1Rlc3QgVm90ZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ+y0iOq4sCDtiKztkZwg7JWE7J207YWc65Ok7J20IO2RnOyLnOuQmOyWtOyVvCDtlagnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8gQXJ0aXN0IOydtOumhOydtCBKU09OIOqwneyytOuhnCDsoIDsnqXrkJjrr4DroZwg7KCB7KCI7ZWcIO2FjeyKpO2KuOulvCDssL7slYTslbwg7ZWoXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvQXJ0aXN0IDF87JWE7Yuw7Iqk7Yq4LykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCftj7Trp4Eg66qo65OcIO2FjOyKpO2KuCcsICgpID0+IHtcbiAgICBpdCgn7Y+066eBIOuqqOuTnOyXkOyEnCDsp4DsoJXrkJwg6rCE6rKp7Jy866GcIOuNsOydtO2EsOulvCDqsIDsoLjsmYDslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17ZmFsc2V9XG4gICAgICAgICAgcG9sbGluZ0ludGVydmFsPXsxMDAwfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8g7LSI6riwIO2YuOy2nFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuZnJvbSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxDYWxsQ291bnQgPSBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrLmNhbGxzLmxlbmd0aDtcblxuICAgICAgLy8gMey0iCDtm4Qg7LaU6rCAIO2YuOy2nCDtmZXsnbhcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oaW5pdGlhbENhbGxDb3VudCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCftj7Trp4Eg7JeQ65+sIOuwnOyDnSDsi5wg7JeQ65+sIOyVjOumvOydtCDtkZzsi5zrkJjslrTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtb2NrU2VsZWN0IH0gPSBjcmVhdGVNb2NrQ2hhaW4odW5kZWZpbmVkLCBuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgICAgZW5hYmxlUmVhbHRpbWU9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIOyXkOufrCDslYzrprzsnbQg7ZGc7Iuc65CY64qU7KeAIO2ZleyduFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoL+uNsOydtO2EsCDroZzrlKkg7Jik66WYfOyYpOulmHxlcnJvci9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ+2PtOungSDshLHqs7Ug7IucIO2IrO2RnCDrjbDsnbTthLDqsIAg7JeF642w7J207Yq465CY7Ja07JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgdGl0bGU6IHsga286ICdVcGRhdGVkIFZvdGUnIH0sXG4gICAgICAgICAgdm90ZV9jb250ZW50OiAnVXBkYXRlZCBkZXNjcmlwdGlvbicsXG4gICAgICAgICAgdm90ZV9pdGVtOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICB2b3RlX3RvdGFsOiAxNTAsIC8vIOyXheuNsOydtO2KuOuQnCDtiKztkZwg7IiYXG4gICAgICAgICAgICAgIGFydGlzdDogeyBpZDogMSwgbmFtZTogeyBrbzogJ0FydGlzdCAxJyB9LCBpbWFnZTogJ2FydGlzdDEuanBnJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyBtb2NrU2VsZWN0IH0gPSBjcmVhdGVNb2NrQ2hhaW4odXBkYXRlZERhdGEpO1xuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXtmYWxzZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyDsl4XrjbDsnbTtirjrkJwg642w7J207YSw6rCAIO2RnOyLnOuQmOuKlOyngCDtmZXsnbggKDE1MOydtOudvOuKlCDsiKvsnpDqsIAg7ZmU66m07JeQIOyeiOuKlOyngCDtmZXsnbgpXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJzE1MCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfsoJXsoIEg66qo65OcIO2FjOyKpO2KuCcsICgpID0+IHtcbiAgICBpdCgn7KCV7KCBIOuqqOuTnOyXkOyEnOuKlCDsnpDrj5kg7JeF642w7J207Yq46rCAIOuwnOyDne2VmOyngCDslYrslYTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17ZmFsc2V9XG4gICAgICAgICAgcG9sbGluZ0ludGVydmFsPXswfSAvLyDtj7Trp4Eg67mE7Zmc7ISx7ZmUXG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBjb25zdCBpbml0aWFsQ2FsbENvdW50ID0gbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9jay5jYWxscy5sZW5ndGg7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg1MDAwKTsgLy8gNey0iCDrjIDquLBcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBUEkg7Zi47Lac7J20IOy2lOqwgOuhnCDrsJzsg53tlZjsp4Ag7JWK7JWY64qU7KeAIO2ZleyduFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKGluaXRpYWxDYWxsQ291bnQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgn7Iuk7Iuc6rCEIOuqqOuTnCDthYzsiqTtirgnLCAoKSA9PiB7XG4gICAgaXQoJ+yLpOyLnOqwhCDrqqjrk5zqsIAg7Zmc7ISx7ZmU65CgIOuVjCBTdXBhYmFzZSDssYTrhJDsnYQg6rWs64+F7ZW07JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdWJzY3JpYmUgPSBqZXN0LmZuKCk7XG4gICAgICBjb25zdCBtb2NrT24gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc3Vic2NyaWJlOiBtb2NrU3Vic2NyaWJlIH0pO1xuICAgICAgXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuY2hhbm5lbC5tb2NrUmV0dXJuVmFsdWUoeyBvbjogbW9ja09uIH0pO1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXt0cnVlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuY2hhbm5lbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N1cGFiYXNlX3JlYWx0aW1lJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCfsi6Tsi5zqsIQg7Jew6rKwIOyLpO2MqCDsi5wg7Y+066eBIOuqqOuTnOuhnCDsnpDrj5kg7KCE7ZmY65CY7Ja07JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdWJzY3JpYmUgPSBqZXN0LmZuPChjYWxsYmFjazogKHN0YXR1czogc3RyaW5nLCBlcnJvcj86IEVycm9yKSA9PiB2b2lkKSA9PiBhbnk+KCk7XG4gICAgICBtb2NrU3Vic2NyaWJlLm1vY2tJbXBsZW1lbnRhdGlvbigoY2FsbGJhY2s6IChzdGF0dXM6IHN0cmluZywgZXJyb3I/OiBFcnJvcikgPT4gdm9pZCkgPT4ge1xuICAgICAgICAvLyDsl7DqsrAg7Iuk7YyoIOyLnOuurOugiOydtOyFmFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCdDSEFOTkVMX0VSUk9SJywgbmV3IEVycm9yKCdDb25uZWN0aW9uIGZhaWxlZCcpKSwgMTAwKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IGplc3QuZm4oKSB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT24gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc3Vic2NyaWJlOiBtb2NrU3Vic2NyaWJlIH0pO1xuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmNoYW5uZWwubW9ja1JldHVyblZhbHVlKHsgb246IG1vY2tPbiB9KTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17dHJ1ZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIO2PtOungSDrqqjrk5zroZwg7KCE7ZmYIO2ZleyduCAoQVBJIO2YuOy2nOydtCDsi5zsnpHrkJjsl4jripTsp4Ag7ZmV7J24KVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2VDbGllbnQuZnJvbSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfsl7DqsrAg7ZKI7KeIIOuqqOuLiO2EsOungSDthYzsiqTtirgnLCAoKSA9PiB7XG4gICAgaXQoJ+yXsOyGjSDsl5Drn6wg67Cc7IOdIOyLnCDsl5Drn6zqsIAg64iE7KCB65CY7Ja07JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIOyXkOufrOulvCDrsJjtmZjtlZjripQg66qo7YK5IOyEpOyglVxuICAgICAgY29uc3QgeyBtb2NrU2VsZWN0IH0gPSBjcmVhdGVNb2NrQ2hhaW4odW5kZWZpbmVkLCBuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgICAgZW5hYmxlUmVhbHRpbWU9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8g7Jes65+sIOuyiOydmCDtj7Trp4HsnLzroZwg7Jew7IaNIOyXkOufrCDrsJzsg51cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8g7JeQ65+sIOuplOyLnOyngOqwgCDtkZzsi5zrkJjripTsp4Ag7ZmV7J24XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgv7Jik66WYfGVycm9yL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfshLHriqUg7YWM7Iqk7Yq4JywgKCkgPT4ge1xuICAgIGl0KCfruYjrsojtlZwg642w7J207YSwIOyXheuNsOydtO2KuCDsi5wg66mU66qo66asIOuIhOyImOqwgCDrsJzsg53tlZjsp4Ag7JWK7JWE7JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17ZmFsc2V9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyDsl6zrn6wg67KI7J2YIOu5oOuluCDsl4XrjbDsnbTtirgg7Iuc666s66CI7J207IWYXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIOy7tO2PrOuEjO2KuCDslrjrp4jsmrTtirhcbiAgICAgIHVubW91bnQoKTtcblxuICAgICAgLy8g7YOA7J2066i46rCAIOygleumrOuQmOyXiOuKlOyngCDtmZXsnbhcbiAgICAgIGV4cGVjdChqZXN0LmdldFRpbWVyQ291bnQoKSkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+yXkOufrCDrs7Xqtawg7YWM7Iqk7Yq4JywgKCkgPT4ge1xuICAgIGl0KCfrhKTtirjsm4ztgawg67O16rWsIO2bhCDsoJXsg4Eg64+Z7J6R7Jy866GcIOuPjOyVhOyZgOyVvCDtlagnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgc2hvdWxkRXJyb3IgPSB0cnVlO1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbjwoKSA9PiBQcm9taXNlPE1vY2tTdXBhYmFzZVJlc3BvbnNlPj4oKTtcbiAgICAgIG1vY2tTaW5nbGUubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIHZvdGVfaXRlbTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgICAgdm90ZV90b3RhbDogMTAwLFxuICAgICAgICAgICAgICAgIGFydGlzdDogeyBpZDogMSwgbmFtZTogeyBrbzogJ0FydGlzdCAxJyB9LCBpbWFnZTogJ2FydGlzdDEuanBnJyB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXtmYWxzZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIOy0iOq4sCDsl5Drn6wg7IOB7YOcXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC/smKTrpZh8ZXJyb3IvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8g64Sk7Yq47JuM7YGsIOuzteq1rCDsi5zrrqzroIjsnbTshZhcbiAgICAgIHNob3VsZEVycm9yID0gZmFsc2U7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyDsoJXsg4Eg64+Z7J6RIOuzteq1rCDtmZXsnbggKOyXkOufrCDrqZTsi5zsp4DqsIAg7IKs65287KGM64qU7KeAIO2ZleyduClcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC/rjbDsnbTthLAg66Gc65SpIOyYpOulmC8pKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQiLCJhdXRoIiwiZ2V0VXNlciIsImplc3QiLCJmbiIsImZyb20iLCJjaGFubmVsIiwibW9ja1N1cGFiYXNlQ2xpZW50IiwibW9jayIsImNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudCIsInVzZUxhbmd1YWdlU3RvcmUiLCJjdXJyZW50TGFuZ3VhZ2UiLCJ1c2VBdXRoR3VhcmQiLCJ1c2VyIiwiaWQiLCJlbWFpbCIsInNlc3Npb24iLCJhY2Nlc3NfdG9rZW4iLCJpc0xvYWRpbmciLCJzaWduT3V0IiwicmVxdWlyZUF1dGgiLCJ1c2VSZXF1aXJlQXV0aCIsIndpdGhBdXRoIiwiYXJncyIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwidXNlQXV0aCIsIm1vY2tWb3RlIiwidGl0bGUiLCJrbyIsInZvdGVfY29udGVudCIsInN0YXJ0X2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3RvcF9hdCIsImFyZWEiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImRlbGV0ZWRfYXQiLCJtYWluX2ltYWdlIiwib3JkZXIiLCJyZXN1bHRfaW1hZ2UiLCJ2aXNpYmxlX2F0Iiwidm90ZV9jYXRlZ29yeSIsInZvdGVfc3ViX2NhdGVnb3J5Iiwid2FpdF9pbWFnZSIsIm1vY2tWb3RlSXRlbXMiLCJhcnRpc3RfaWQiLCJncm91cF9pZCIsInZvdGVfaWQiLCJ2b3RlX3RvdGFsIiwiYXJ0aXN0IiwibmFtZSIsImltYWdlIiwiYmlydGhfZGF0ZSIsImRlYnV0X2RhdGUiLCJkZWJ1dF9kZCIsImRlYnV0X21tIiwiZGVidXRfeXkiLCJnZW5kZXIiLCJpc19rcG9wIiwiaXNfbXVzaWNhbCIsImlzX3NvbG8iLCJkZCIsIm1tIiwieXkiLCJjcmVhdGVNb2NrQ2hhaW4iLCJyZXNvbHZlVmFsdWUiLCJyZWplY3RWYWx1ZSIsIm1vY2tTaW5nbGUiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsInZvdGVfaXRlbSIsIm1vY2tFcSIsIm1vY2tSZXR1cm5WYWx1ZSIsInNpbmdsZSIsIm1vY2tTZWxlY3QiLCJlcSIsIlRlc3RXcmFwcGVyIiwibW9ja0F1dGhDb250ZXh0IiwiUmVhY3QiLCJ1c2VNZW1vIiwiZGl2IiwiZGF0YS10ZXN0aWQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwidXNlRmFrZVRpbWVycyIsInNlbGVjdCIsImFmdGVyRWFjaCIsInVzZVJlYWxUaW1lcnMiLCJpdCIsInJlbmRlciIsIkh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXIiLCJ2b3RlIiwiaW5pdGlhbEl0ZW1zIiwiZXhwZWN0Iiwic2NyZWVuIiwiZ2V0QnlUZXh0IiwidG9CZUluVGhlRG9jdW1lbnQiLCJlbmFibGVSZWFsdGltZSIsInBvbGxpbmdJbnRlcnZhbCIsIndhaXRGb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiaW5pdGlhbENhbGxDb3VudCIsImNhbGxzIiwibGVuZ3RoIiwiYWN0IiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInRvQmVHcmVhdGVyVGhhbiIsInVuZGVmaW5lZCIsIkVycm9yIiwicXVlcnlCeVRleHQiLCJ1cGRhdGVkRGF0YSIsInRvQmUiLCJtb2NrU3Vic2NyaWJlIiwibW9ja09uIiwic3Vic2NyaWJlIiwib24iLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsInVuc3Vic2NyaWJlIiwiaSIsInVubW91bnQiLCJnZXRUaW1lckNvdW50Iiwic2hvdWxkRXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzb2x2ZSIsIm5vdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OERBQWtCO3dCQUNzQzt5QkFDbkM7MkNBQ3FCOzs7Ozs7QUFpQjFDLDRDQUE0QztBQUM1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