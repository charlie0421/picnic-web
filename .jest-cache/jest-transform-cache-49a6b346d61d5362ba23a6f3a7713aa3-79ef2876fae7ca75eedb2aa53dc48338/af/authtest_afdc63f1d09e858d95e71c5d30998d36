9745da6313b6d215b75319f90eca5b80
/**
 * Auth API 유틸리티 테스트
 */ "use strict";
jest.mock('../../../lib/supabase/client', ()=>({
        createBrowserSupabaseClient: jest.fn(()=>({
                auth: {
                    getSession: jest.fn(),
                    onAuthStateChange: jest.fn(()=>({
                            data: {
                                subscription: {
                                    unsubscribe: jest.fn()
                                }
                            }
                        }))
                }
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _auth = require("../../../utils/api/auth");
// 세션 모킹
const mockSession = {
    user: {
        id: 'test-user-id',
        email: 'test@example.com',
        app_metadata: {},
        user_metadata: {},
        aud: 'authenticated',
        created_at: '2023-01-01T00:00:00.000Z'
    },
    access_token: 'mock-access-token',
    token_type: 'bearer',
    expires_in: 3600,
    refresh_token: 'mock-refresh-token'
};
const mockSupabase = _auth.supabase;
describe('Auth API Utils', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // console.error 모킹
        jest.spyOn(console, 'error').mockImplementation(()=>{});
        // 환경 변수 설정
        process.env.NEXT_PUBLIC_CDN_URL = 'https://cdn.example.com';
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    describe('isUserLoggedIn', ()=>{
        it('returns true when user has active session', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: {
                        user: {
                            id: 'user-123'
                        },
                        access_token: 'token-123'
                    }
                },
                error: null
            });
            const result = await (0, _auth.isUserLoggedIn)();
            expect(result).toBe(true);
            expect(mockSupabase.auth.getSession).toHaveBeenCalledTimes(1);
        });
        it('returns false when user has no session', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: null
                },
                error: null
            });
            const result = await (0, _auth.isUserLoggedIn)();
            expect(result).toBe(false);
            expect(mockSupabase.auth.getSession).toHaveBeenCalledTimes(1);
        });
        it('returns false when session is undefined', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: undefined
                },
                error: null
            });
            const result = await (0, _auth.isUserLoggedIn)();
            expect(result).toBe(false);
        });
        it('handles auth errors gracefully', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: null
                },
                error: {
                    message: 'Auth error'
                }
            });
            const result = await (0, _auth.isUserLoggedIn)();
            expect(result).toBe(false);
        });
    });
    describe('getUserProfile', ()=>{
        const mockFrom = jest.fn();
        const mockSelect = jest.fn();
        const mockEq = jest.fn();
        const mockSingle = jest.fn();
        beforeEach(()=>{
            mockSupabase.from.mockReturnValue({
                select: mockSelect
            });
            mockSelect.mockReturnValue({
                eq: mockEq
            });
            mockEq.mockReturnValue({
                single: mockSingle
            });
        });
        it('returns user profile data successfully', async ()=>{
            const mockProfile = {
                id: 'user-123',
                email: 'test@example.com',
                name: 'Test User'
            };
            mockSingle.mockResolvedValue({
                data: mockProfile,
                error: null
            });
            const result = await (0, _auth.getUserProfile)('user-123');
            expect(result).toEqual(mockProfile);
            expect(mockSupabase.from).toHaveBeenCalledWith('user_profiles');
            expect(mockSelect).toHaveBeenCalledWith('*');
            expect(mockEq).toHaveBeenCalledWith('id', 'user-123');
            expect(mockSingle).toHaveBeenCalledTimes(1);
        });
        it('throws error when profile not found', async ()=>{
            const mockError = {
                message: 'Profile not found'
            };
            mockSingle.mockResolvedValue({
                data: null,
                error: mockError
            });
            await expect((0, _auth.getUserProfile)('nonexistent-user')).rejects.toEqual(mockError);
        });
        it('throws error when database query fails', async ()=>{
            const mockError = {
                message: 'Database connection failed'
            };
            mockSingle.mockResolvedValue({
                data: null,
                error: mockError
            });
            await expect((0, _auth.getUserProfile)('user-123')).rejects.toEqual(mockError);
        });
    });
    describe('getStorageUrl', ()=>{
        const mockStorageFrom = jest.fn();
        const mockGetPublicUrl = jest.fn();
        beforeEach(()=>{
            mockSupabase.storage.from.mockReturnValue({
                getPublicUrl: mockGetPublicUrl
            });
        });
        it('returns public URL for storage file', ()=>{
            const mockUrl = 'https://storage.example.com/bucket/path/file.jpg';
            mockGetPublicUrl.mockReturnValue({
                data: {
                    publicUrl: mockUrl
                }
            });
            const result = (0, _auth.getStorageUrl)('avatars', 'user/profile.jpg');
            expect(result).toBe(mockUrl);
            expect(mockSupabase.storage.from).toHaveBeenCalledWith('avatars');
            expect(mockGetPublicUrl).toHaveBeenCalledWith('user/profile.jpg');
        });
        it('handles different bucket and path combinations', ()=>{
            const mockUrl = 'https://storage.example.com/images/banner.png';
            mockGetPublicUrl.mockReturnValue({
                data: {
                    publicUrl: mockUrl
                }
            });
            const result = (0, _auth.getStorageUrl)('images', 'banners/banner.png');
            expect(result).toBe(mockUrl);
            expect(mockSupabase.storage.from).toHaveBeenCalledWith('images');
            expect(mockGetPublicUrl).toHaveBeenCalledWith('banners/banner.png');
        });
    });
    describe('getCdnUrl', ()=>{
        it('returns CDN URL with path', ()=>{
            const result = (0, _auth.getCdnUrl)('/images/logo.png');
            expect(result).toBe('https://cdn.example.com/images/logo.png');
        });
        it('handles path without leading slash', ()=>{
            const result = (0, _auth.getCdnUrl)('images/logo.png');
            expect(result).toBe('https://cdn.example.comimages/logo.png');
        });
        it('handles empty path', ()=>{
            const result = (0, _auth.getCdnUrl)('');
            expect(result).toBe('https://cdn.example.com');
        });
        it('handles undefined CDN URL environment variable', ()=>{
            delete process.env.NEXT_PUBLIC_CDN_URL;
            const result = (0, _auth.getCdnUrl)('/images/logo.png');
            expect(result).toBe('undefined/images/logo.png');
        });
    });
    describe('uploadFile', ()=>{
        const mockStorageFrom = jest.fn();
        const mockUpload = jest.fn();
        beforeEach(()=>{
            mockSupabase.storage.from.mockReturnValue({
                upload: mockUpload
            });
        });
        it('uploads file successfully', async ()=>{
            const mockFile = new File([
                'test content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const mockUploadData = {
                path: 'uploads/test.txt',
                id: 'file-123',
                fullPath: 'bucket/uploads/test.txt'
            };
            mockUpload.mockResolvedValue({
                data: mockUploadData,
                error: null
            });
            const result = await (0, _auth.uploadFile)('uploads', 'test.txt', mockFile);
            expect(result).toEqual(mockUploadData);
            expect(mockSupabase.storage.from).toHaveBeenCalledWith('uploads');
            expect(mockUpload).toHaveBeenCalledWith('test.txt', mockFile);
        });
        it('throws error when upload fails', async ()=>{
            const mockFile = new File([
                'test content'
            ], 'test.txt', {
                type: 'text/plain'
            });
            const mockError = {
                message: 'Upload failed'
            };
            mockUpload.mockResolvedValue({
                data: null,
                error: mockError
            });
            await expect((0, _auth.uploadFile)('uploads', 'test.txt', mockFile)).rejects.toEqual(mockError);
        });
        it('handles different file types', async ()=>{
            const mockImageFile = new File([
                'image data'
            ], 'image.jpg', {
                type: 'image/jpeg'
            });
            const mockUploadData = {
                path: 'images/image.jpg',
                id: 'image-123'
            };
            mockUpload.mockResolvedValue({
                data: mockUploadData,
                error: null
            });
            const result = await (0, _auth.uploadFile)('images', 'profile/image.jpg', mockImageFile);
            expect(result).toEqual(mockUploadData);
            expect(mockSupabase.storage.from).toHaveBeenCalledWith('images');
            expect(mockUpload).toHaveBeenCalledWith('profile/image.jpg', mockImageFile);
        });
        it('handles storage quota exceeded error', async ()=>{
            const mockFile = new File([
                'large content'
            ], 'large.txt', {
                type: 'text/plain'
            });
            const mockError = {
                message: 'Storage quota exceeded'
            };
            mockUpload.mockResolvedValue({
                data: null,
                error: mockError
            });
            await expect((0, _auth.uploadFile)('uploads', 'large.txt', mockFile)).rejects.toEqual(mockError);
        });
    });
    describe('supabase export', ()=>{
        it('exports supabase client', ()=>{
            expect(_auth.supabase).toBeDefined();
            expect(_auth.supabase.auth).toBeDefined();
            expect(_auth.supabase.from).toBeDefined();
            expect(_auth.supabase.storage).toBeDefined();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFybGllLmh5dW4vUmVwb3NpdG9yaWVzL3BpY25pYy13ZWIvX190ZXN0c19fL3V0aWxzL2FwaS9hdXRoLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdXRoIEFQSSDsnKDti7jrpqzti7Ag7YWM7Iqk7Yq4XG4gKi9cblxuaW1wb3J0IHsgXG4gIGlzVXNlckxvZ2dlZEluLCBcbiAgZ2V0VXNlclByb2ZpbGUsIFxuICBnZXRTdG9yYWdlVXJsLCBcbiAgZ2V0Q2RuVXJsLCBcbiAgdXBsb2FkRmlsZSxcbiAgc3VwYWJhc2UsXG4gIGhhbmRsZVBlbmRpbmdBdXRoXG59IGZyb20gJy4uLy4uLy4uL3V0aWxzL2FwaS9hdXRoJztcblxuLy8g7IS47IWYIOuqqO2CuVxuY29uc3QgbW9ja1Nlc3Npb24gPSB7XG4gIHVzZXI6IHtcbiAgICBpZDogJ3Rlc3QtdXNlci1pZCcsXG4gICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBhcHBfbWV0YWRhdGE6IHt9LFxuICAgIHVzZXJfbWV0YWRhdGE6IHt9LFxuICAgIGF1ZDogJ2F1dGhlbnRpY2F0ZWQnLFxuICAgIGNyZWF0ZWRfYXQ6ICcyMDIzLTAxLTAxVDAwOjAwOjAwLjAwMFonLFxuICB9LFxuICBhY2Nlc3NfdG9rZW46ICdtb2NrLWFjY2Vzcy10b2tlbicsXG4gIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICBleHBpcmVzX2luOiAzNjAwLFxuICByZWZyZXNoX3Rva2VuOiAnbW9jay1yZWZyZXNoLXRva2VuJyxcbn07XG5cbmplc3QubW9jaygnLi4vLi4vLi4vbGliL3N1cGFiYXNlL2NsaWVudCcsICgpID0+ICh7XG4gIGNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudDogamVzdC5mbigoKSA9PiAoe1xuICAgIGF1dGg6IHtcbiAgICAgIGdldFNlc3Npb246IGplc3QuZm4oKSxcbiAgICAgIG9uQXV0aFN0YXRlQ2hhbmdlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGRhdGE6IHsgc3Vic2NyaXB0aW9uOiB7IHVuc3Vic2NyaWJlOiBqZXN0LmZuKCkgfSB9XG4gICAgICB9KSksXG4gICAgfSxcbiAgfSkpLFxufSkpO1xuXG5jb25zdCBtb2NrU3VwYWJhc2UgPSBzdXBhYmFzZSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2Ygc3VwYWJhc2U+O1xuXG5kZXNjcmliZSgnQXV0aCBBUEkgVXRpbHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIC8vIGNvbnNvbGUuZXJyb3Ig66qo7YK5XG4gICAgamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuICAgIC8vIO2ZmOqyvSDrs4DsiJgg7ISk7KCVXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0ROX1VSTCA9ICdodHRwczovL2Nkbi5leGFtcGxlLmNvbSc7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2lzVXNlckxvZ2dlZEluJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIHRydWUgd2hlbiB1c2VyIGhhcyBhY3RpdmUgc2Vzc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLmdldFNlc3Npb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2Vzc2lvbjoge1xuICAgICAgICAgICAgdXNlcjogeyBpZDogJ3VzZXItMTIzJyB9LFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiAndG9rZW4tMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXNVc2VyTG9nZ2VkSW4oKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgZmFsc2Ugd2hlbiB1c2VyIGhhcyBubyBzZXNzaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXNVc2VyTG9nZ2VkSW4oKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5hdXRoLmdldFNlc3Npb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXR1cm5zIGZhbHNlIHdoZW4gc2Vzc2lvbiBpcyB1bmRlZmluZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiB1bmRlZmluZWQgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzVXNlckxvZ2dlZEluKCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGF1dGggZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdBdXRoIGVycm9yJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpc1VzZXJMb2dnZWRJbigpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyUHJvZmlsZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKTtcbiAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpO1xuICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKTtcbiAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9IGFzIGFueSk7XG4gICAgICBtb2NrU2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9IGFzIGFueSk7XG4gICAgICBtb2NrRXEubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiBtb2NrU2luZ2xlLFxuICAgICAgfSBhcyBhbnkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgdXNlciBwcm9maWxlIGRhdGEgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Byb2ZpbGUgPSB7XG4gICAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUHJvZmlsZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlclByb2ZpbGUoJ3VzZXItMTIzJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2ZpbGUpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5mcm9tKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndXNlcl9wcm9maWxlcycpO1xuICAgICAgZXhwZWN0KG1vY2tTZWxlY3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcqJyk7XG4gICAgICBleHBlY3QobW9ja0VxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaWQnLCAndXNlci0xMjMnKTtcbiAgICAgIGV4cGVjdChtb2NrU2luZ2xlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgndGhyb3dzIGVycm9yIHdoZW4gcHJvZmlsZSBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSB7IG1lc3NhZ2U6ICdQcm9maWxlIG5vdCBmb3VuZCcgfTtcbiAgICAgIG1vY2tTaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbW9ja0Vycm9yLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyUHJvZmlsZSgnbm9uZXhpc3RlbnQtdXNlcicpKS5yZWplY3RzLnRvRXF1YWwobW9ja0Vycm9yKTtcbiAgICB9KTtcblxuICAgIGl0KCd0aHJvd3MgZXJyb3Igd2hlbiBkYXRhYmFzZSBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvciA9IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyB9O1xuICAgICAgbW9ja1NpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBtb2NrRXJyb3IsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KGdldFVzZXJQcm9maWxlKCd1c2VyLTEyMycpKS5yZWplY3RzLnRvRXF1YWwobW9ja0Vycm9yKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFN0b3JhZ2VVcmwnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1N0b3JhZ2VGcm9tID0gamVzdC5mbigpO1xuICAgIGNvbnN0IG1vY2tHZXRQdWJsaWNVcmwgPSBqZXN0LmZuKCk7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zdG9yYWdlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZ2V0UHVibGljVXJsOiBtb2NrR2V0UHVibGljVXJsLFxuICAgICAgfSBhcyBhbnkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JldHVybnMgcHVibGljIFVSTCBmb3Igc3RvcmFnZSBmaWxlJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VybCA9ICdodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vYnVja2V0L3BhdGgvZmlsZS5qcGcnO1xuICAgICAgbW9ja0dldFB1YmxpY1VybC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHB1YmxpY1VybDogbW9ja1VybCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFN0b3JhZ2VVcmwoJ2F2YXRhcnMnLCAndXNlci9wcm9maWxlLmpwZycpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKG1vY2tVcmwpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5zdG9yYWdlLmZyb20pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhdmF0YXJzJyk7XG4gICAgICBleHBlY3QobW9ja0dldFB1YmxpY1VybCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3VzZXIvcHJvZmlsZS5qcGcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGRpZmZlcmVudCBidWNrZXQgYW5kIHBhdGggY29tYmluYXRpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VybCA9ICdodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vaW1hZ2VzL2Jhbm5lci5wbmcnO1xuICAgICAgbW9ja0dldFB1YmxpY1VybC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHB1YmxpY1VybDogbW9ja1VybCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFN0b3JhZ2VVcmwoJ2ltYWdlcycsICdiYW5uZXJzL2Jhbm5lci5wbmcnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrVXJsKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2Uuc3RvcmFnZS5mcm9tKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaW1hZ2VzJyk7XG4gICAgICBleHBlY3QobW9ja0dldFB1YmxpY1VybCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2Jhbm5lcnMvYmFubmVyLnBuZycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Q2RuVXJsJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIENETiBVUkwgd2l0aCBwYXRoJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2RuVXJsKCcvaW1hZ2VzL2xvZ28ucG5nJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdodHRwczovL2Nkbi5leGFtcGxlLmNvbS9pbWFnZXMvbG9nby5wbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHBhdGggd2l0aG91dCBsZWFkaW5nIHNsYXNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2RuVXJsKCdpbWFnZXMvbG9nby5wbmcnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ2h0dHBzOi8vY2RuLmV4YW1wbGUuY29taW1hZ2VzL2xvZ28ucG5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBlbXB0eSBwYXRoJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2RuVXJsKCcnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ2h0dHBzOi8vY2RuLmV4YW1wbGUuY29tJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyB1bmRlZmluZWQgQ0ROIFVSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScsICgpID0+IHtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DRE5fVVJMO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2RuVXJsKCcvaW1hZ2VzL2xvZ28ucG5nJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCd1bmRlZmluZWQvaW1hZ2VzL2xvZ28ucG5nJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd1cGxvYWRGaWxlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tTdG9yYWdlRnJvbSA9IGplc3QuZm4oKTtcbiAgICBjb25zdCBtb2NrVXBsb2FkID0gamVzdC5mbigpO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc3RvcmFnZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVwbG9hZDogbW9ja1VwbG9hZCxcbiAgICAgIH0gYXMgYW55KTtcbiAgICB9KTtcblxuICAgIGl0KCd1cGxvYWRzIGZpbGUgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ3Rlc3QgY29udGVudCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGxvYWREYXRhID0ge1xuICAgICAgICBwYXRoOiAndXBsb2Fkcy90ZXN0LnR4dCcsXG4gICAgICAgIGlkOiAnZmlsZS0xMjMnLFxuICAgICAgICBmdWxsUGF0aDogJ2J1Y2tldC91cGxvYWRzL3Rlc3QudHh0JyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tVcGxvYWQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrVXBsb2FkRGF0YSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkRmlsZSgndXBsb2FkcycsICd0ZXN0LnR4dCcsIG1vY2tGaWxlKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrVXBsb2FkRGF0YSk7XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnN0b3JhZ2UuZnJvbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3VwbG9hZHMnKTtcbiAgICAgIGV4cGVjdChtb2NrVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC50eHQnLCBtb2NrRmlsZSk7XG4gICAgfSk7XG5cbiAgICBpdCgndGhyb3dzIGVycm9yIHdoZW4gdXBsb2FkIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ3Rlc3QgY29udGVudCddLCAndGVzdC50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcnJvciA9IHsgbWVzc2FnZTogJ1VwbG9hZCBmYWlsZWQnIH07XG5cbiAgICAgIG1vY2tVcGxvYWQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbW9ja0Vycm9yLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1cGxvYWRGaWxlKCd1cGxvYWRzJywgJ3Rlc3QudHh0JywgbW9ja0ZpbGUpKS5yZWplY3RzLnRvRXF1YWwobW9ja0Vycm9yKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGRpZmZlcmVudCBmaWxlIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ltYWdlRmlsZSA9IG5ldyBGaWxlKFsnaW1hZ2UgZGF0YSddLCAnaW1hZ2UuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICBjb25zdCBtb2NrVXBsb2FkRGF0YSA9IHtcbiAgICAgICAgcGF0aDogJ2ltYWdlcy9pbWFnZS5qcGcnLFxuICAgICAgICBpZDogJ2ltYWdlLTEyMycsXG4gICAgICB9O1xuXG4gICAgICBtb2NrVXBsb2FkLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1VwbG9hZERhdGEsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZEZpbGUoJ2ltYWdlcycsICdwcm9maWxlL2ltYWdlLmpwZycsIG1vY2tJbWFnZUZpbGUpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tVcGxvYWREYXRhKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2Uuc3RvcmFnZS5mcm9tKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaW1hZ2VzJyk7XG4gICAgICBleHBlY3QobW9ja1VwbG9hZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Byb2ZpbGUvaW1hZ2UuanBnJywgbW9ja0ltYWdlRmlsZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgRmlsZShbJ2xhcmdlIGNvbnRlbnQnXSwgJ2xhcmdlLnR4dCcsIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pO1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0geyBtZXNzYWdlOiAnU3RvcmFnZSBxdW90YSBleGNlZWRlZCcgfTtcblxuICAgICAgbW9ja1VwbG9hZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBtb2NrRXJyb3IsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHVwbG9hZEZpbGUoJ3VwbG9hZHMnLCAnbGFyZ2UudHh0JywgbW9ja0ZpbGUpKS5yZWplY3RzLnRvRXF1YWwobW9ja0Vycm9yKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3N1cGFiYXNlIGV4cG9ydCcsICgpID0+IHtcbiAgICBpdCgnZXhwb3J0cyBzdXBhYmFzZSBjbGllbnQnLCAoKSA9PiB7XG4gICAgICBleHBlY3Qoc3VwYWJhc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3VwYWJhc2UuYXV0aCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzdXBhYmFzZS5mcm9tKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHN1cGFiYXNlLnN0b3JhZ2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJjcmVhdGVCcm93c2VyU3VwYWJhc2VDbGllbnQiLCJmbiIsImF1dGgiLCJnZXRTZXNzaW9uIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJkYXRhIiwic3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJtb2NrU2Vzc2lvbiIsInVzZXIiLCJpZCIsImVtYWlsIiwiYXBwX21ldGFkYXRhIiwidXNlcl9tZXRhZGF0YSIsImF1ZCIsImNyZWF0ZWRfYXQiLCJhY2Nlc3NfdG9rZW4iLCJ0b2tlbl90eXBlIiwiZXhwaXJlc19pbiIsInJlZnJlc2hfdG9rZW4iLCJtb2NrU3VwYWJhc2UiLCJzdXBhYmFzZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ0ROX1VSTCIsImFmdGVyRWFjaCIsInJlc3RvcmVBbGxNb2NrcyIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzZXNzaW9uIiwiZXJyb3IiLCJyZXN1bHQiLCJpc1VzZXJMb2dnZWRJbiIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJ1bmRlZmluZWQiLCJtZXNzYWdlIiwibW9ja0Zyb20iLCJtb2NrU2VsZWN0IiwibW9ja0VxIiwibW9ja1NpbmdsZSIsImZyb20iLCJtb2NrUmV0dXJuVmFsdWUiLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsIm1vY2tQcm9maWxlIiwibmFtZSIsImdldFVzZXJQcm9maWxlIiwidG9FcXVhbCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibW9ja0Vycm9yIiwicmVqZWN0cyIsIm1vY2tTdG9yYWdlRnJvbSIsIm1vY2tHZXRQdWJsaWNVcmwiLCJzdG9yYWdlIiwiZ2V0UHVibGljVXJsIiwibW9ja1VybCIsInB1YmxpY1VybCIsImdldFN0b3JhZ2VVcmwiLCJnZXRDZG5VcmwiLCJtb2NrVXBsb2FkIiwidXBsb2FkIiwibW9ja0ZpbGUiLCJGaWxlIiwidHlwZSIsIm1vY2tVcGxvYWREYXRhIiwicGF0aCIsImZ1bGxQYXRoIiwidXBsb2FkRmlsZSIsIm1vY2tJbWFnZUZpbGUiLCJ0b0JlRGVmaW5lZCJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7QUE0QkRBLEtBQUtDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBTyxDQUFBO1FBQy9DQyw2QkFBNkJGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQzFDQyxNQUFNO29CQUNKQyxZQUFZTCxLQUFLRyxFQUFFO29CQUNuQkcsbUJBQW1CTixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBOzRCQUNoQ0ksTUFBTTtnQ0FBRUMsY0FBYztvQ0FBRUMsYUFBYVQsS0FBS0csRUFBRTtnQ0FBRzs0QkFBRTt3QkFDbkQsQ0FBQTtnQkFDRjtZQUNGLENBQUE7SUFDRixDQUFBOzs7O3NCQTNCTztBQUVQLFFBQVE7QUFDUixNQUFNTyxjQUFjO0lBQ2xCQyxNQUFNO1FBQ0pDLElBQUk7UUFDSkMsT0FBTztRQUNQQyxjQUFjLENBQUM7UUFDZkMsZUFBZSxDQUFDO1FBQ2hCQyxLQUFLO1FBQ0xDLFlBQVk7SUFDZDtJQUNBQyxjQUFjO0lBQ2RDLFlBQVk7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