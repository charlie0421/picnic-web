2fb2706ffddbb28afb0ed6ea7794fc24
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
const _HybridVoteDetailPresenter = require("../../../components/client/vote/detail/HybridVoteDetailPresenter");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock Supabase client with explicit typing
const createMockSupabaseClient = ()=>({
        auth: {
            getUser: _globals.jest.fn()
        },
        from: _globals.jest.fn(),
        channel: _globals.jest.fn()
    });
const mockSupabaseClient = createMockSupabaseClient();
// Mock hooks
_globals.jest.mock('@/lib/supabase/client', ()=>({
        createBrowserSupabaseClient: ()=>mockSupabaseClient
    }));
_globals.jest.mock('@/stores/languageStore', ()=>({
        useLanguageStore: ()=>({
                currentLanguage: 'ko'
            })
    }));
// Mock useAuthGuard hook completely
_globals.jest.mock('@/hooks/useAuthGuard', ()=>({
        useAuthGuard: _globals.jest.fn(()=>({
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                },
                session: {
                    access_token: 'mock-token'
                },
                isLoading: false,
                signOut: _globals.jest.fn(),
                requireAuth: _globals.jest.fn()
            })),
        useRequireAuth: _globals.jest.fn(()=>({
                withAuth: _globals.jest.fn((fn)=>(...args)=>fn(...args))
            }))
    }));
// Mock AuthProvider completely
_globals.jest.mock('@/lib/supabase/auth-provider', ()=>({
        AuthProvider: ({ children })=>children,
        useAuth: _globals.jest.fn(()=>({
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                },
                session: {
                    access_token: 'mock-token'
                },
                isLoading: false,
                signOut: _globals.jest.fn()
            }))
    }));
// Mock data with correct types
const mockVote = {
    id: 1,
    title: {
        ko: 'Test Vote'
    },
    vote_content: 'Test vote description',
    start_at: new Date('2024-01-01T00:00:00Z').toISOString(),
    stop_at: new Date('2024-12-31T23:59:59Z').toISOString(),
    area: 'global',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    deleted_at: null,
    main_image: null,
    order: null,
    result_image: null,
    visible_at: null,
    vote_category: null,
    vote_sub_category: null,
    wait_image: null
};
const mockVoteItems = [
    {
        id: 1,
        artist_id: 1,
        group_id: 1,
        vote_id: 1,
        vote_total: 100,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        deleted_at: null,
        artist: {
            id: 1,
            name: {
                ko: 'Artist 1'
            },
            image: 'https://example.com/artist1.jpg',
            birth_date: null,
            created_at: new Date().toISOString(),
            debut_date: null,
            debut_dd: null,
            debut_mm: null,
            debut_yy: null,
            deleted_at: null,
            gender: null,
            group_id: null,
            is_kpop: true,
            is_musical: false,
            is_solo: true,
            updated_at: new Date().toISOString(),
            dd: null,
            mm: null,
            yy: null
        }
    },
    {
        id: 2,
        artist_id: 2,
        group_id: 1,
        vote_id: 1,
        vote_total: 50,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        deleted_at: null,
        artist: {
            id: 2,
            name: {
                ko: 'Artist 2'
            },
            image: 'https://example.com/artist2.jpg',
            birth_date: null,
            created_at: new Date().toISOString(),
            debut_date: null,
            debut_dd: null,
            debut_mm: null,
            debut_yy: null,
            deleted_at: null,
            gender: null,
            group_id: null,
            is_kpop: true,
            is_musical: false,
            is_solo: true,
            updated_at: new Date().toISOString(),
            dd: null,
            mm: null,
            yy: null
        }
    }
];
// Helper function to create mock chain
const createMockChain = (resolveValue, rejectValue)=>{
    const mockSingle = _globals.jest.fn();
    if (rejectValue) {
        mockSingle.mockRejectedValue(rejectValue);
    } else {
        mockSingle.mockResolvedValue(resolveValue || {
            data: {
                id: 1,
                title: {
                    ko: 'Test Vote'
                },
                vote_content: 'Test vote description',
                vote_item: [
                    {
                        id: 1,
                        vote_total: 100,
                        artist: {
                            id: 1,
                            name: {
                                ko: 'Artist 1'
                            },
                            image: 'artist1.jpg'
                        }
                    },
                    {
                        id: 2,
                        vote_total: 50,
                        artist: {
                            id: 2,
                            name: {
                                ko: 'Artist 2'
                            },
                            image: 'artist2.jpg'
                        }
                    }
                ]
            }
        });
    }
    const mockEq = _globals.jest.fn().mockReturnValue({
        single: mockSingle
    });
    const mockSelect = _globals.jest.fn().mockReturnValue({
        eq: mockEq
    });
    return {
        mockSelect,
        mockEq,
        mockSingle
    };
};
// Test Wrapper with complete mocked context
const TestWrapper = ({ children })=>{
    const mockAuthContext = _react.default.useMemo(()=>({
            user: {
                id: 'user123',
                email: 'test@example.com'
            },
            session: {
                access_token: 'mock-token'
            },
            isLoading: false,
            signOut: _globals.jest.fn()
        }), []);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        "data-testid": "auth-provider",
        children: children
    });
};
describe('HybridVoteDetailPresenter', ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        _globals.jest.useFakeTimers();
        // Setup default mocks with proper typing
        mockSupabaseClient.auth.getUser.mockResolvedValue({
            data: {
                user: {
                    id: 'user123',
                    email: 'test@example.com'
                }
            }
        });
        const { mockSelect } = createMockChain();
        mockSupabaseClient.from.mockReturnValue({
            select: mockSelect
        });
    });
    afterEach(()=>{
        _globals.jest.useRealTimers();
    });
    describe('기본 렌더링 테스트', ()=>{
        it('컴포넌트가 정상적으로 렌더링되어야 함', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems
            }));
            // 투표 제목 확인 (JSON 객체에서 한국어 제목 추출)
            expect(_react1.screen.getByText('Test Vote')).toBeInTheDocument();
        });
        it('초기 투표 아이템들이 표시되어야 함', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems
            }));
            // Artist 이름이 JSON 객체로 저장되므로 적절한 텍스트를 찾아야 함
            expect(_react1.screen.getByText(/Artist 1|아티스트/)).toBeInTheDocument();
        });
    });
    describe('폴링 모드 테스트', ()=>{
        it('폴링 모드에서 지정된 간격으로 데이터를 가져와야 함', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false,
                pollingInterval: 1000
            }));
            // 초기 호출
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from).toHaveBeenCalled();
            });
            const initialCallCount = mockSupabaseClient.from.mock.calls.length;
            // 1초 후 추가 호출 확인
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from.mock.calls.length).toBeGreaterThan(initialCallCount);
            });
        });
        it('폴링 에러 발생 시 에러 알림이 표시되어야 함', async ()=>{
            const { mockSelect } = createMockChain(undefined, new Error('Network error'));
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 에러 알림이 표시되는지 확인
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/데이터 로딩 오류|오류|error/i)).toBeInTheDocument();
            });
        });
        it('폴링 성공 시 투표 데이터가 업데이트되어야 함', async ()=>{
            const updatedData = {
                data: {
                    id: 1,
                    title: {
                        ko: 'Updated Vote'
                    },
                    vote_content: 'Updated description',
                    vote_item: [
                        {
                            id: 1,
                            vote_total: 150,
                            artist: {
                                id: 1,
                                name: {
                                    ko: 'Artist 1'
                                },
                                image: 'artist1.jpg'
                            }
                        }
                    ]
                }
            };
            const { mockSelect } = createMockChain(updatedData);
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 업데이트된 데이터가 표시되는지 확인 (150이라는 숫자가 화면에 있는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText('150')).toBeInTheDocument();
            });
        });
    });
    describe('정적 모드 테스트', ()=>{
        it('정적 모드에서는 자동 업데이트가 발생하지 않아야 함', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false,
                pollingInterval: 0
            }));
            const initialCallCount = mockSupabaseClient.from.mock.calls.length;
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(5000); // 5초 대기
            });
            // API 호출이 추가로 발생하지 않았는지 확인
            expect(mockSupabaseClient.from.mock.calls.length).toBe(initialCallCount);
        });
    });
    describe('실시간 모드 테스트', ()=>{
        it('실시간 모드가 활성화될 때 Supabase 채널을 구독해야 함', async ()=>{
            const mockSubscribe = _globals.jest.fn();
            const mockOn = _globals.jest.fn().mockReturnValue({
                subscribe: mockSubscribe
            });
            mockSupabaseClient.channel.mockReturnValue({
                on: mockOn
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: true
            }));
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.channel).toHaveBeenCalledWith('supabase_realtime');
            });
        });
        it('실시간 연결 실패 시 폴링 모드로 자동 전환되어야 함', async ()=>{
            const mockSubscribe = _globals.jest.fn();
            mockSubscribe.mockImplementation((callback)=>{
                // 연결 실패 시뮬레이션
                setTimeout(()=>callback('CHANNEL_ERROR', new Error('Connection failed')), 100);
                return {
                    unsubscribe: _globals.jest.fn()
                };
            });
            const mockOn = _globals.jest.fn().mockReturnValue({
                subscribe: mockSubscribe
            });
            mockSupabaseClient.channel.mockReturnValue({
                on: mockOn
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: true
            }));
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(200);
            });
            // 폴링 모드로 전환 확인 (API 호출이 시작되었는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(mockSupabaseClient.from).toHaveBeenCalled();
            });
        });
    });
    describe('연결 품질 모니터링 테스트', ()=>{
        it('연속 에러 발생 시 에러가 누적되어야 함', async ()=>{
            // 에러를 반환하는 모킹 설정
            const { mockSelect } = createMockChain(undefined, new Error('Network error'));
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 여러 번의 폴링으로 연속 에러 발생
            for(let i = 0; i < 3; i++){
                await (0, _react1.act)(async ()=>{
                    _globals.jest.advanceTimersByTime(1000);
                });
            }
            // 에러 메시지가 표시되는지 확인
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/오류|error/i)).toBeInTheDocument();
            });
        });
    });
    describe('성능 테스트', ()=>{
        it('빈번한 데이터 업데이트 시 메모리 누수가 발생하지 않아야 함', async ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 여러 번의 빠른 업데이트 시뮬레이션
            for(let i = 0; i < 10; i++){
                await (0, _react1.act)(async ()=>{
                    _globals.jest.advanceTimersByTime(100);
                });
            }
            // 컴포넌트 언마운트
            unmount();
            // 타이머가 정리되었는지 확인
            expect(_globals.jest.getTimerCount()).toBe(0);
        });
    });
    describe('에러 복구 테스트', ()=>{
        it('네트워크 복구 후 정상 동작으로 돌아와야 함', async ()=>{
            let shouldError = true;
            const mockSingle = _globals.jest.fn();
            mockSingle.mockImplementation(()=>{
                if (shouldError) {
                    return Promise.reject(new Error('Network error'));
                }
                return Promise.resolve({
                    data: {
                        id: 1,
                        vote_item: [
                            {
                                id: 1,
                                vote_total: 100,
                                artist: {
                                    id: 1,
                                    name: {
                                        ko: 'Artist 1'
                                    },
                                    image: 'artist1.jpg'
                                }
                            }
                        ]
                    }
                });
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_HybridVoteDetailPresenter.HybridVoteDetailPresenter, {
                vote: mockVote,
                initialItems: mockVoteItems,
                enableRealtime: false
            }));
            // 초기 에러 상태
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText(/오류|error/i)).toBeInTheDocument();
            });
            // 네트워크 복구 시뮬레이션
            shouldError = false;
            await (0, _react1.act)(async ()=>{
                _globals.jest.advanceTimersByTime(1000);
            });
            // 정상 동작 복구 확인 (에러 메시지가 사라졌는지 확인)
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText(/데이터 로딩 오류/)).not.toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFybGllLmh5dW4vUmVwb3NpdG9yaWVzL3BpY25pYy13ZWIvX190ZXN0c19fL2NvbXBvbmVudHMvdm90ZS9IeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciwgZmlyZUV2ZW50LCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXIgfSBmcm9tICdAL2NvbXBvbmVudHMvY2xpZW50L3ZvdGUvZGV0YWlsL0h5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXInO1xuaW1wb3J0IHsgVm90ZSwgVm90ZUl0ZW0gfSBmcm9tICdAL3R5cGVzL2ludGVyZmFjZXMnO1xuXG4vLyBDcmVhdGUgcHJvcGVyIG1vY2sgdHlwZXNcbmludGVyZmFjZSBNb2NrU3VwYWJhc2VSZXNwb25zZSB7XG4gIGRhdGE6IGFueTtcbiAgZXJyb3I/OiBhbnk7XG59XG5cbmludGVyZmFjZSBNb2NrU3VwYWJhc2VDbGllbnQge1xuICBhdXRoOiB7XG4gICAgZ2V0VXNlcjogamVzdC5Nb2NrZWRGdW5jdGlvbjwoKSA9PiBQcm9taXNlPGFueT4+O1xuICB9O1xuICBmcm9tOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPCh0YWJsZTogc3RyaW5nKSA9PiBhbnk+O1xuICBjaGFubmVsOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPChuYW1lOiBzdHJpbmcpID0+IGFueT47XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgY2xpZW50IHdpdGggZXhwbGljaXQgdHlwaW5nXG5jb25zdCBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQgPSAoKTogTW9ja1N1cGFiYXNlQ2xpZW50ID0+ICh7XG4gIGF1dGg6IHtcbiAgICBnZXRVc2VyOiBqZXN0LmZuPCgpID0+IFByb21pc2U8YW55Pj4oKSxcbiAgfSxcbiAgZnJvbTogamVzdC5mbjwodGFibGU6IHN0cmluZykgPT4gYW55PigpLFxuICBjaGFubmVsOiBqZXN0LmZuPChuYW1lOiBzdHJpbmcpID0+IGFueT4oKSxcbn0pO1xuXG5jb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcblxuLy8gTW9jayBob29rc1xuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZS9jbGllbnQnLCAoKSA9PiAoe1xuICBjcmVhdGVCcm93c2VyU3VwYWJhc2VDbGllbnQ6ICgpID0+IG1vY2tTdXBhYmFzZUNsaWVudCxcbn0pKTtcblxuamVzdC5tb2NrKCdAL3N0b3Jlcy9sYW5ndWFnZVN0b3JlJywgKCkgPT4gKHtcbiAgdXNlTGFuZ3VhZ2VTdG9yZTogKCkgPT4gKHtcbiAgICBjdXJyZW50TGFuZ3VhZ2U6ICdrbycsXG4gIH0pLFxufSkpO1xuXG4vLyBNb2NrIHVzZUF1dGhHdWFyZCBob29rIGNvbXBsZXRlbHlcbmplc3QubW9jaygnQC9ob29rcy91c2VBdXRoR3VhcmQnLCAoKSA9PiAoe1xuICB1c2VBdXRoR3VhcmQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICB1c2VyOiB7IGlkOiAndXNlcjEyMycsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSxcbiAgICBzZXNzaW9uOiB7IGFjY2Vzc190b2tlbjogJ21vY2stdG9rZW4nIH0sXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBzaWduT3V0OiBqZXN0LmZuKCksXG4gICAgcmVxdWlyZUF1dGg6IGplc3QuZm4oKSxcbiAgfSkpLFxuICB1c2VSZXF1aXJlQXV0aDogamVzdC5mbigoKSA9PiAoe1xuICAgIHdpdGhBdXRoOiBqZXN0LmZuKChmbjogYW55KSA9PiAoLi4uYXJnczogYW55W10pID0+IChmbiBhcyBhbnkpKC4uLmFyZ3MpKSxcbiAgfSkpLFxufSkpO1xuXG4vLyBNb2NrIEF1dGhQcm92aWRlciBjb21wbGV0ZWx5XG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlL2F1dGgtcHJvdmlkZXInLCAoKSA9PiAoe1xuICBBdXRoUHJvdmlkZXI6ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiBjaGlsZHJlbixcbiAgdXNlQXV0aDogamVzdC5mbigoKSA9PiAoe1xuICAgIHVzZXI6IHsgaWQ6ICd1c2VyMTIzJywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9LFxuICAgIHNlc3Npb246IHsgYWNjZXNzX3Rva2VuOiAnbW9jay10b2tlbicgfSxcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHNpZ25PdXQ6IGplc3QuZm4oKSxcbiAgfSkpLFxufSkpO1xuXG4vLyBNb2NrIGRhdGEgd2l0aCBjb3JyZWN0IHR5cGVzXG5jb25zdCBtb2NrVm90ZTogVm90ZSA9IHtcbiAgaWQ6IDEsXG4gIHRpdGxlOiB7IGtvOiAnVGVzdCBWb3RlJyB9LFxuICB2b3RlX2NvbnRlbnQ6ICdUZXN0IHZvdGUgZGVzY3JpcHRpb24nLFxuICBzdGFydF9hdDogbmV3IERhdGUoJzIwMjQtMDEtMDFUMDA6MDA6MDBaJykudG9JU09TdHJpbmcoKSxcbiAgc3RvcF9hdDogbmV3IERhdGUoJzIwMjQtMTItMzFUMjM6NTk6NTlaJykudG9JU09TdHJpbmcoKSxcbiAgYXJlYTogJ2dsb2JhbCcsXG4gIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICBkZWxldGVkX2F0OiBudWxsLFxuICBtYWluX2ltYWdlOiBudWxsLFxuICBvcmRlcjogbnVsbCxcbiAgcmVzdWx0X2ltYWdlOiBudWxsLFxuICB2aXNpYmxlX2F0OiBudWxsLFxuICB2b3RlX2NhdGVnb3J5OiBudWxsLFxuICB2b3RlX3N1Yl9jYXRlZ29yeTogbnVsbCxcbiAgd2FpdF9pbWFnZTogbnVsbCxcbn07XG5cbmNvbnN0IG1vY2tWb3RlSXRlbXM6IFZvdGVJdGVtW10gPSBbXG4gIHtcbiAgICBpZDogMSxcbiAgICBhcnRpc3RfaWQ6IDEsXG4gICAgZ3JvdXBfaWQ6IDEsXG4gICAgdm90ZV9pZDogMSxcbiAgICB2b3RlX3RvdGFsOiAxMDAsXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkZWxldGVkX2F0OiBudWxsLFxuICAgIGFydGlzdDoge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiB7IGtvOiAnQXJ0aXN0IDEnIH0sXG4gICAgICBpbWFnZTogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXJ0aXN0MS5qcGcnLFxuICAgICAgYmlydGhfZGF0ZTogbnVsbCxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRlYnV0X2RhdGU6IG51bGwsXG4gICAgICBkZWJ1dF9kZDogbnVsbCxcbiAgICAgIGRlYnV0X21tOiBudWxsLFxuICAgICAgZGVidXRfeXk6IG51bGwsXG4gICAgICBkZWxldGVkX2F0OiBudWxsLFxuICAgICAgZ2VuZGVyOiBudWxsLFxuICAgICAgZ3JvdXBfaWQ6IG51bGwsXG4gICAgICBpc19rcG9wOiB0cnVlLFxuICAgICAgaXNfbXVzaWNhbDogZmFsc2UsXG4gICAgICBpc19zb2xvOiB0cnVlLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGQ6IG51bGwsXG4gICAgICBtbTogbnVsbCxcbiAgICAgIHl5OiBudWxsLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBpZDogMixcbiAgICBhcnRpc3RfaWQ6IDIsXG4gICAgZ3JvdXBfaWQ6IDEsXG4gICAgdm90ZV9pZDogMSxcbiAgICB2b3RlX3RvdGFsOiA1MCxcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGRlbGV0ZWRfYXQ6IG51bGwsXG4gICAgYXJ0aXN0OiB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6IHsga286ICdBcnRpc3QgMicgfSxcbiAgICAgIGltYWdlOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hcnRpc3QyLmpwZycsXG4gICAgICBiaXJ0aF9kYXRlOiBudWxsLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZGVidXRfZGF0ZTogbnVsbCxcbiAgICAgIGRlYnV0X2RkOiBudWxsLFxuICAgICAgZGVidXRfbW06IG51bGwsXG4gICAgICBkZWJ1dF95eTogbnVsbCxcbiAgICAgIGRlbGV0ZWRfYXQ6IG51bGwsXG4gICAgICBnZW5kZXI6IG51bGwsXG4gICAgICBncm91cF9pZDogbnVsbCxcbiAgICAgIGlzX2twb3A6IHRydWUsXG4gICAgICBpc19tdXNpY2FsOiBmYWxzZSxcbiAgICAgIGlzX3NvbG86IHRydWUsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkZDogbnVsbCxcbiAgICAgIG1tOiBudWxsLFxuICAgICAgeXk6IG51bGwsXG4gICAgfSxcbiAgfSxcbl07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbW9jayBjaGFpblxuY29uc3QgY3JlYXRlTW9ja0NoYWluID0gKHJlc29sdmVWYWx1ZT86IGFueSwgcmVqZWN0VmFsdWU/OiBhbnkpID0+IHtcbiAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm48KCkgPT4gUHJvbWlzZTxNb2NrU3VwYWJhc2VSZXNwb25zZT4+KCk7XG4gIFxuICBpZiAocmVqZWN0VmFsdWUpIHtcbiAgICBtb2NrU2luZ2xlLm1vY2tSZWplY3RlZFZhbHVlKHJlamVjdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBtb2NrU2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHJlc29sdmVWYWx1ZSB8fCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB0aXRsZTogeyBrbzogJ1Rlc3QgVm90ZScgfSxcbiAgICAgICAgdm90ZV9jb250ZW50OiAnVGVzdCB2b3RlIGRlc2NyaXB0aW9uJyxcbiAgICAgICAgdm90ZV9pdGVtOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICB2b3RlX3RvdGFsOiAxMDAsXG4gICAgICAgICAgICBhcnRpc3Q6IHsgaWQ6IDEsIG5hbWU6IHsga286ICdBcnRpc3QgMScgfSwgaW1hZ2U6ICdhcnRpc3QxLmpwZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgdm90ZV90b3RhbDogNTAsXG4gICAgICAgICAgICBhcnRpc3Q6IHsgaWQ6IDIsIG5hbWU6IHsga286ICdBcnRpc3QgMicgfSwgaW1hZ2U6ICdhcnRpc3QyLmpwZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgcmV0dXJuIHsgbW9ja1NlbGVjdCwgbW9ja0VxLCBtb2NrU2luZ2xlIH07XG59O1xuXG4vLyBUZXN0IFdyYXBwZXIgd2l0aCBjb21wbGV0ZSBtb2NrZWQgY29udGV4dFxuY29uc3QgVGVzdFdyYXBwZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgbW9ja0F1dGhDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHVzZXI6IHsgaWQ6ICd1c2VyMTIzJywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9LFxuICAgIHNlc3Npb246IHsgYWNjZXNzX3Rva2VuOiAnbW9jay10b2tlbicgfSxcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHNpZ25PdXQ6IGplc3QuZm4oKSxcbiAgfSksIFtdKTtcbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cImF1dGgtcHJvdmlkZXJcIj5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmRlc2NyaWJlKCdIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICBcbiAgICAvLyBTZXR1cCBkZWZhdWx0IG1vY2tzIHdpdGggcHJvcGVyIHR5cGluZ1xuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5hdXRoLmdldFVzZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgZGF0YTogeyB1c2VyOiB7IGlkOiAndXNlcjEyMycsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSB9LFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHsgbW9ja1NlbGVjdCB9ID0gY3JlYXRlTW9ja0NoYWluKCk7XG4gICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICB9KTtcblxuICBkZXNjcmliZSgn6riw67O4IOugjOuNlOungSDthYzsiqTtirgnLCAoKSA9PiB7XG4gICAgaXQoJ+y7tO2PrOuEjO2KuOqwgCDsoJXsg4HsoIHsnLzroZwg66CM642U66eB65CY7Ja07JW8IO2VqCcsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyDtiKztkZwg7KCc66qpIO2ZleyduCAoSlNPTiDqsJ3ssrTsl5DshJwg7ZWc6rWt7Ja0IOygnOuqqSDstpTstpwpXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVGVzdCBWb3RlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgn7LSI6riwIO2IrO2RnCDslYTsnbTthZzrk6TsnbQg7ZGc7Iuc65CY7Ja07JW8IO2VqCcsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBBcnRpc3Qg7J2066aE7J20IEpTT04g6rCd7LK066GcIOyggOyepeuQmOuvgOuhnCDsoIHsoIjtlZwg7YWN7Iqk7Yq466W8IOywvuyVhOyVvCDtlahcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9BcnRpc3QgMXzslYTti7DsiqTtirgvKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+2PtOungSDrqqjrk5wg7YWM7Iqk7Yq4JywgKCkgPT4ge1xuICAgIGl0KCftj7Trp4Eg66qo65Oc7JeQ7IScIOyngOygleuQnCDqsITqsqnsnLzroZwg642w7J207YSw66W8IOqwgOyguOyZgOyVvCDtlagnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXtmYWxzZX1cbiAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWw9ezEwMDB9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyDstIjquLAg7Zi47LacXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW5pdGlhbENhbGxDb3VudCA9IG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2suY2FsbHMubGVuZ3RoO1xuXG4gICAgICAvLyAx7LSIIO2bhCDstpTqsIAg7Zi47LacIO2ZleyduFxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9jay5jYWxscy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbihpbml0aWFsQ2FsbENvdW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ+2PtOungSDsl5Drn6wg67Cc7IOdIOyLnCDsl5Drn6wg7JWM66a87J20IO2RnOyLnOuQmOyWtOyVvCDtlagnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IG1vY2tTZWxlY3QgfSA9IGNyZWF0ZU1vY2tDaGFpbih1bmRlZmluZWQsIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17ZmFsc2V9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG4gICAgICB9KTtcblxuICAgICAgLy8g7JeQ65+sIOyVjOumvOydtCDtkZzsi5zrkJjripTsp4Ag7ZmV7J24XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgv642w7J207YSwIOuhnOuUqSDsmKTrpZh87Jik66WYfGVycm9yL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgn7Y+066eBIOyEseqztSDsi5wg7Yis7ZGcIOuNsOydtO2EsOqwgCDsl4XrjbDsnbTtirjrkJjslrTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICB0aXRsZTogeyBrbzogJ1VwZGF0ZWQgVm90ZScgfSxcbiAgICAgICAgICB2b3RlX2NvbnRlbnQ6ICdVcGRhdGVkIGRlc2NyaXB0aW9uJyxcbiAgICAgICAgICB2b3RlX2l0ZW06IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgIHZvdGVfdG90YWw6IDE1MCwgLy8g7JeF642w7J207Yq465CcIO2IrO2RnCDsiJhcbiAgICAgICAgICAgICAgYXJ0aXN0OiB7IGlkOiAxLCBuYW1lOiB7IGtvOiAnQXJ0aXN0IDEnIH0sIGltYWdlOiAnYXJ0aXN0MS5qcGcnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IG1vY2tTZWxlY3QgfSA9IGNyZWF0ZU1vY2tDaGFpbih1cGRhdGVkRGF0YSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgICAgZW5hYmxlUmVhbHRpbWU9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIOyXheuNsOydtO2KuOuQnCDrjbDsnbTthLDqsIAg7ZGc7Iuc65CY64qU7KeAIO2ZleyduCAoMTUw7J20652864qUIOyIq+yekOqwgCDtmZTrqbTsl5Ag7J6I64qU7KeAIO2ZleyduClcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnMTUwJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+ygleyggSDrqqjrk5wg7YWM7Iqk7Yq4JywgKCkgPT4ge1xuICAgIGl0KCfsoJXsoIEg66qo65Oc7JeQ7ISc64qUIOyekOuPmSDsl4XrjbDsnbTtirjqsIAg67Cc7IOd7ZWY7KeAIOyViuyVhOyVvCDtlagnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXtmYWxzZX1cbiAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWw9ezB9IC8vIO2PtOungSDruYTtmZzshLHtmZRcbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxDYWxsQ291bnQgPSBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrLmNhbGxzLmxlbmd0aDtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDUwMDApOyAvLyA17LSIIOuMgOq4sFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFQSSDtmLjstpzsnbQg7LaU6rCA66GcIOuwnOyDne2VmOyngCDslYrslZjripTsp4Ag7ZmV7J24XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9jay5jYWxscy5sZW5ndGgpLnRvQmUoaW5pdGlhbENhbGxDb3VudCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfsi6Tsi5zqsIQg66qo65OcIO2FjOyKpO2KuCcsICgpID0+IHtcbiAgICBpdCgn7Iuk7Iuc6rCEIOuqqOuTnOqwgCDtmZzshLHtmZTrkKAg65WMIFN1cGFiYXNlIOyxhOuEkOydhCDqtazrj4XtlbTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1YnNjcmliZSA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IG1vY2tPbiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzdWJzY3JpYmU6IG1vY2tTdWJzY3JpYmUgfSk7XG4gICAgICBcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5jaGFubmVsLm1vY2tSZXR1cm5WYWx1ZSh7IG9uOiBtb2NrT24gfSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgICAgZW5hYmxlUmVhbHRpbWU9e3RydWV9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5jaGFubmVsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3VwYWJhc2VfcmVhbHRpbWUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ+yLpOyLnOqwhCDsl7DqsrAg7Iuk7YyoIOyLnCDtj7Trp4Eg66qo65Oc66GcIOyekOuPmSDsoITtmZjrkJjslrTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1YnNjcmliZSA9IGplc3QuZm48KGNhbGxiYWNrOiAoc3RhdHVzOiBzdHJpbmcsIGVycm9yPzogRXJyb3IpID0+IHZvaWQpID0+IGFueT4oKTtcbiAgICAgIG1vY2tTdWJzY3JpYmUubW9ja0ltcGxlbWVudGF0aW9uKChjYWxsYmFjazogKHN0YXR1czogc3RyaW5nLCBlcnJvcj86IEVycm9yKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIC8vIOyXsOqysCDsi6TtjKgg7Iuc666s66CI7J207IWYXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soJ0NIQU5ORUxfRVJST1InLCBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkJykpLCAxMDApO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogamVzdC5mbigpIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tPbiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzdWJzY3JpYmU6IG1vY2tTdWJzY3JpYmUgfSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuY2hhbm5lbC5tb2NrUmV0dXJuVmFsdWUoeyBvbjogbW9ja09uIH0pO1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXt0cnVlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDIwMCk7XG4gICAgICB9KTtcblxuICAgICAgLy8g7Y+066eBIOuqqOuTnOuhnCDsoITtmZgg7ZmV7J24IChBUEkg7Zi47Lac7J20IOyLnOyekeuQmOyXiOuKlOyngCDtmZXsnbgpXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+yXsOqysCDtkojsp4gg66qo64uI7YSw66eBIO2FjOyKpO2KuCcsICgpID0+IHtcbiAgICBpdCgn7Jew7IaNIOyXkOufrCDrsJzsg50g7IucIOyXkOufrOqwgCDriITsoIHrkJjslrTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8g7JeQ65+s66W8IOuwmO2ZmO2VmOuKlCDrqqjtgrkg7ISk7KCVXG4gICAgICBjb25zdCB7IG1vY2tTZWxlY3QgfSA9IGNyZWF0ZU1vY2tDaGFpbih1bmRlZmluZWQsIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8SHlicmlkVm90ZURldGFpbFByZXNlbnRlclxuICAgICAgICAgIHZvdGU9e21vY2tWb3RlfVxuICAgICAgICAgIGluaXRpYWxJdGVtcz17bW9ja1ZvdGVJdGVtc31cbiAgICAgICAgICBlbmFibGVSZWFsdGltZT17ZmFsc2V9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyDsl6zrn6wg67KI7J2YIO2PtOungeycvOuhnCDsl7Dsho0g7JeQ65+sIOuwnOyDnVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyDsl5Drn6wg66mU7Iuc7KeA6rCAIO2RnOyLnOuQmOuKlOyngCDtmZXsnbhcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC/smKTrpZh8ZXJyb3IvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ+yEseuKpSDthYzsiqTtirgnLCAoKSA9PiB7XG4gICAgaXQoJ+u5iOuyiO2VnCDrjbDsnbTthLAg7JeF642w7J207Yq4IOyLnCDrqZTrqqjrpqwg64iE7IiY6rCAIOuwnOyDne2VmOyngCDslYrslYTslbwg7ZWoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgIDxIeWJyaWRWb3RlRGV0YWlsUHJlc2VudGVyXG4gICAgICAgICAgdm90ZT17bW9ja1ZvdGV9XG4gICAgICAgICAgaW5pdGlhbEl0ZW1zPXttb2NrVm90ZUl0ZW1zfVxuICAgICAgICAgIGVuYWJsZVJlYWx0aW1lPXtmYWxzZX1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIOyXrOufrCDrsojsnZgg67mg66W4IOyXheuNsOydtO2KuCDsi5zrrqzroIjsnbTshZhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8g7Lu07Y+s64SM7Yq4IOyWuOuniOyatO2KuFxuICAgICAgdW5tb3VudCgpO1xuXG4gICAgICAvLyDtg4DsnbTrqLjqsIAg7KCV66as65CY7JeI64qU7KeAIO2ZleyduFxuICAgICAgZXhwZWN0KGplc3QuZ2V0VGltZXJDb3VudCgpKS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgn7JeQ65+sIOuzteq1rCDthYzsiqTtirgnLCAoKSA9PiB7XG4gICAgaXQoJ+uEpO2KuOybjO2BrCDrs7Xqtawg7ZuEIOygleyDgSDrj5nsnpHsnLzroZwg64+M7JWE7JmA7JW8IO2VqCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzaG91bGRFcnJvciA9IHRydWU7XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuPCgpID0+IFByb21pc2U8TW9ja1N1cGFiYXNlUmVzcG9uc2U+PigpO1xuICAgICAgbW9ja1NpbmdsZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgdm90ZV9pdGVtOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICB2b3RlX3RvdGFsOiAxMDAsXG4gICAgICAgICAgICAgICAgYXJ0aXN0OiB7IGlkOiAxLCBuYW1lOiB7IGtvOiAnQXJ0aXN0IDEnIH0sIGltYWdlOiAnYXJ0aXN0MS5qcGcnIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEh5YnJpZFZvdGVEZXRhaWxQcmVzZW50ZXJcbiAgICAgICAgICB2b3RlPXttb2NrVm90ZX1cbiAgICAgICAgICBpbml0aWFsSXRlbXM9e21vY2tWb3RlSXRlbXN9XG4gICAgICAgICAgZW5hYmxlUmVhbHRpbWU9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8g7LSI6riwIOyXkOufrCDsg4Htg5xcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL+yYpOulmHxlcnJvci9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyDrhKTtirjsm4ztgawg67O16rWsIOyLnOuurOugiOydtOyFmFxuICAgICAgc2hvdWxkRXJyb3IgPSBmYWxzZTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIOygleyDgSDrj5nsnpEg67O16rWsIO2ZleyduCAo7JeQ65+sIOuplOyLnOyngOqwgCDsgqzrnbzsoYzripTsp4Ag7ZmV7J24KVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoL+uNsOydtO2EsCDroZzrlKkg7Jik66WYLykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCIsImF1dGgiLCJnZXRVc2VyIiwiamVzdCIsImZuIiwiZnJvbSIsImNoYW5uZWwiLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJtb2NrIiwiY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50IiwidXNlTGFuZ3VhZ2VTdG9yZSIsImN1cnJlbnRMYW5ndWFnZSIsInVzZUF1dGhHdWFyZCIsInVzZXIiLCJpZCIsImVtYWlsIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsImlzTG9hZGluZyIsInNpZ25PdXQiLCJyZXF1aXJlQXV0aCIsInVzZVJlcXVpcmVBdXRoIiwid2l0aEF1dGgiLCJhcmdzIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VBdXRoIiwibW9ja1ZvdGUiLCJ0aXRsZSIsImtvIiwidm90ZV9jb250ZW50Iiwic3RhcnRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzdG9wX2F0IiwiYXJlYSIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwiZGVsZXRlZF9hdCIsIm1haW5faW1hZ2UiLCJvcmRlciIsInJlc3VsdF9pbWFnZSIsInZpc2libGVfYXQiLCJ2b3RlX2NhdGVnb3J5Iiwidm90ZV9zdWJfY2F0ZWdvcnkiLCJ3YWl0X2ltYWdlIiwibW9ja1ZvdGVJdGVtcyIsImFydGlzdF9pZCIsImdyb3VwX2lkIiwidm90ZV9pZCIsInZvdGVfdG90YWwiLCJhcnRpc3QiLCJuYW1lIiwiaW1hZ2UiLCJiaXJ0aF9kYXRlIiwiZGVidXRfZGF0ZSIsImRlYnV0X2RkIiwiZGVidXRfbW0iLCJkZWJ1dF95eSIsImdlbmRlciIsImlzX2twb3AiLCJpc19tdXNpY2FsIiwiaXNfc29sbyIsImRkIiwibW0iLCJ5eSIsImNyZWF0ZU1vY2tDaGFpbiIsInJlc29sdmVWYWx1ZSIsInJlamVjdFZhbHVlIiwibW9ja1NpbmdsZSIsIm1vY2tSZWplY3RlZFZhbHVlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwidm90ZV9pdGVtIiwibW9ja0VxIiwibW9ja1JldHVyblZhbHVlIiwic2luZ2xlIiwibW9ja1NlbGVjdCIsImVxIiwiVGVzdFdyYXBwZXIiLCJtb2NrQXV0aENvbnRleHQiLCJSZWFjdCIsInVzZU1lbW8iLCJkaXYiLCJkYXRhLXRlc3RpZCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ1c2VGYWtlVGltZXJzIiwic2VsZWN0IiwiYWZ0ZXJFYWNoIiwidXNlUmVhbFRpbWVycyIsIml0IiwicmVuZGVyIiwiSHlicmlkVm90ZURldGFpbFByZXNlbnRlciIsInZvdGUiLCJpbml0aWFsSXRlbXMiLCJleHBlY3QiLCJzY3JlZW4iLCJnZXRCeVRleHQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsImVuYWJsZVJlYWx0aW1lIiwicG9sbGluZ0ludGVydmFsIiwid2FpdEZvciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJpbml0aWFsQ2FsbENvdW50IiwiY2FsbHMiLCJsZW5ndGgiLCJhY3QiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwidG9CZUdyZWF0ZXJUaGFuIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJxdWVyeUJ5VGV4dCIsInVwZGF0ZWREYXRhIiwidG9CZSIsIm1vY2tTdWJzY3JpYmUiLCJtb2NrT24iLCJzdWJzY3JpYmUiLCJvbiIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwidW5zdWJzY3JpYmUiLCJpIiwidW5tb3VudCIsImdldFRpbWVyQ291bnQiLCJzaG91bGRFcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNvbHZlIiwibm90Il0sIm1hcHBpbmdzIjoiOzs7Ozs4REFBa0I7d0JBQ3NDO3lCQUNuQzsyQ0FDcUI7Ozs7OztBQWlC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